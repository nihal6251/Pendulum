import {
  ALPHA_MODES,
  AbstractBatchRenderer,
  AbstractMultiResource,
  AbstractRenderer,
  AccessibilityManager,
  AnimatedSprite,
  AppLoaderPlugin,
  Application,
  ArrayResource,
  Attribute,
  BLEND_MODES,
  BUFFER_BITS,
  BUFFER_TYPE,
  BaseImageResource,
  BasePrepare,
  BaseRenderTexture,
  BaseTexture,
  BatchDrawCall,
  BatchGeometry,
  BatchPluginFactory,
  BatchRenderer,
  BatchShaderGenerator,
  BatchSystem,
  BatchTextureArray,
  BitmapFont,
  BitmapFontData,
  BitmapFontLoader,
  BitmapText,
  BlobResource,
  Bounds,
  BrowserAdapter,
  Buffer,
  BufferResource,
  CLEAR_MODES,
  COLOR_MASK_BITS,
  CanvasRenderTarget,
  CanvasResource,
  Circle,
  CompressedTextureLoader,
  CompressedTextureResource,
  Container,
  ContextSystem,
  CountLimiter,
  CubeResource,
  DDSLoader,
  DEG_TO_RAD,
  DRAW_MODES,
  DisplayObject,
  ENV,
  Ellipse,
  ExtensionType,
  Extract,
  FORMATS,
  FORMATS_TO_COMPONENTS,
  FillStyle,
  Filter,
  FilterState,
  FilterSystem,
  Framebuffer,
  FramebufferSystem,
  GC_MODES,
  GLFramebuffer,
  GLProgram,
  GLTexture,
  GRAPHICS_CURVES,
  Geometry,
  GeometrySystem,
  Graphics,
  GraphicsData,
  GraphicsGeometry,
  IGLUniformData,
  INSTALLED,
  INTERNAL_FORMATS,
  INTERNAL_FORMAT_TO_BYTES_PER_PIXEL,
  ImageBitmapResource,
  ImageResource,
  InteractionData,
  InteractionEvent,
  InteractionManager,
  InteractionTrackingData,
  KTXLoader,
  LINE_CAP,
  LINE_JOIN,
  LineStyle,
  Loader,
  LoaderResource,
  MASK_TYPES,
  MIPMAP_MODES,
  MSAA_QUALITY,
  MaskData,
  MaskSystem,
  Matrix,
  Mesh,
  MeshBatchUvs,
  MeshGeometry,
  MeshMaterial,
  NineSlicePlane,
  ObjectRenderer,
  ObservablePoint,
  PI_2,
  PRECISION,
  ParticleContainer,
  ParticleRenderer,
  PlaneGeometry,
  Point,
  Polygon,
  Prepare,
  Program,
  ProjectionSystem,
  Quad,
  QuadUv,
  RAD_TO_DEG,
  RENDERER_TYPE,
  Rectangle,
  RenderTexture,
  RenderTexturePool,
  RenderTextureSystem,
  Renderer,
  ResizePlugin,
  Resource,
  RopeGeometry,
  RoundedRectangle,
  Runner,
  SAMPLER_TYPES,
  SCALE_MODES,
  SHAPES,
  SVGResource,
  ScissorSystem,
  Shader,
  ShaderSystem,
  SimpleMesh,
  SimplePlane,
  SimpleRope,
  Sprite,
  SpriteMaskFilter,
  Spritesheet,
  SpritesheetLoader,
  State,
  StateSystem,
  StencilSystem,
  System,
  TARGETS,
  TEXT_GRADIENT,
  TYPES,
  TYPES_TO_BYTES_PER_COMPONENT,
  TYPES_TO_BYTES_PER_PIXEL,
  TemporaryDisplayObject,
  Text,
  TextFormat,
  TextMetrics,
  TextStyle,
  Texture,
  TextureGCSystem,
  TextureLoader,
  TextureMatrix,
  TextureSystem,
  TextureUvs,
  Ticker,
  TickerPlugin,
  TilingSprite,
  TilingSpriteRenderer,
  TimeLimiter,
  Transform,
  UPDATE_PRIORITY,
  UniformGroup,
  VERSION,
  VideoResource,
  ViewableBuffer,
  WRAP_MODES,
  XMLFormat,
  XMLStringFormat,
  accessibleTarget,
  autoDetectFormat,
  autoDetectRenderer,
  autoDetectResource,
  checkMaxIfStatementsInShader,
  createUBOElements,
  defaultFilterVertex,
  defaultVertex$1,
  deprecation,
  extensions,
  filters,
  generateProgram,
  generateUniformBufferSync,
  getTestContext,
  getUBOData,
  graphicsUtils,
  groupD8,
  hex2rgb,
  hex2string,
  interactiveTarget,
  isMobile,
  parseDDS,
  parseKTX,
  resources,
  rgb2hex,
  sayHello,
  settings,
  systems,
  uniformParsers,
  utils_exports
} from "./chunk-32BJ4XQQ.js";
import "./chunk-G3PMV62Z.js";

// node_modules/@pixi/canvas-renderer/dist/esm/canvas-renderer.mjs
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var CanvasMaskManager = (
  /** @class */
  function() {
    function CanvasMaskManager2(renderer) {
      this._foundShapes = [];
      this.renderer = renderer;
    }
    CanvasMaskManager2.prototype.pushMask = function(maskData) {
      var renderer = this.renderer;
      var maskObject = maskData.maskObject || maskData;
      renderer.context.save();
      var foundShapes = this._foundShapes;
      this.recursiveFindShapes(maskObject, foundShapes);
      if (foundShapes.length > 0) {
        var context = renderer.context;
        context.beginPath();
        for (var i = 0; i < foundShapes.length; i++) {
          var shape = foundShapes[i];
          var transform = shape.transform.worldTransform;
          this.renderer.setContextTransform(transform);
          this.renderGraphicsShape(shape);
        }
        foundShapes.length = 0;
        context.clip();
      }
    };
    CanvasMaskManager2.prototype.recursiveFindShapes = function(container, out) {
      if (container.geometry && container.geometry.graphicsData) {
        out.push(container);
      }
      var children = container.children;
      if (children) {
        for (var i = 0; i < children.length; i++) {
          this.recursiveFindShapes(children[i], out);
        }
      }
    };
    CanvasMaskManager2.prototype.renderGraphicsShape = function(graphics) {
      graphics.finishPoly();
      var context = this.renderer.context;
      var graphicsData = graphics.geometry.graphicsData;
      var len = graphicsData.length;
      if (len === 0) {
        return;
      }
      for (var i = 0; i < len; i++) {
        var data = graphicsData[i];
        var shape = data.shape;
        if (shape.type === SHAPES.POLY) {
          var points = shape.points;
          var holes = data.holes;
          var outerArea = void 0;
          var innerArea = void 0;
          var px = void 0;
          var py = void 0;
          context.moveTo(points[0], points[1]);
          for (var j = 1; j < points.length / 2; j++) {
            context.lineTo(points[j * 2], points[j * 2 + 1]);
          }
          if (holes.length > 0) {
            outerArea = 0;
            px = points[0];
            py = points[1];
            for (var j = 2; j + 2 < points.length; j += 2) {
              outerArea += (points[j] - px) * (points[j + 3] - py) - (points[j + 2] - px) * (points[j + 1] - py);
            }
            for (var k = 0; k < holes.length; k++) {
              points = holes[k].shape.points;
              if (!points) {
                continue;
              }
              innerArea = 0;
              px = points[0];
              py = points[1];
              for (var j = 2; j + 2 < points.length; j += 2) {
                innerArea += (points[j] - px) * (points[j + 3] - py) - (points[j + 2] - px) * (points[j + 1] - py);
              }
              if (innerArea * outerArea < 0) {
                context.moveTo(points[0], points[1]);
                for (var j = 2; j < points.length; j += 2) {
                  context.lineTo(points[j], points[j + 1]);
                }
              } else {
                context.moveTo(points[points.length - 2], points[points.length - 1]);
                for (var j = points.length - 4; j >= 0; j -= 2) {
                  context.lineTo(points[j], points[j + 1]);
                }
              }
              if (holes[k].shape.closeStroke) {
                context.closePath();
              }
            }
          }
          if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1]) {
            context.closePath();
          }
        } else if (shape.type === SHAPES.RECT) {
          context.rect(shape.x, shape.y, shape.width, shape.height);
          context.closePath();
        } else if (shape.type === SHAPES.CIRC) {
          context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
          context.closePath();
        } else if (shape.type === SHAPES.ELIP) {
          var w = shape.width * 2;
          var h = shape.height * 2;
          var x = shape.x - w / 2;
          var y = shape.y - h / 2;
          var kappa = 0.5522848;
          var ox = w / 2 * kappa;
          var oy = h / 2 * kappa;
          var xe = x + w;
          var ye = y + h;
          var xm = x + w / 2;
          var ym = y + h / 2;
          context.moveTo(x, ym);
          context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
          context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
          context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
          context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
          context.closePath();
        } else if (shape.type === SHAPES.RREC) {
          var rx = shape.x;
          var ry = shape.y;
          var width = shape.width;
          var height = shape.height;
          var radius = shape.radius;
          var maxRadius = Math.min(width, height) / 2;
          radius = radius > maxRadius ? maxRadius : radius;
          context.moveTo(rx, ry + radius);
          context.lineTo(rx, ry + height - radius);
          context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
          context.lineTo(rx + width - radius, ry + height);
          context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
          context.lineTo(rx + width, ry + radius);
          context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
          context.lineTo(rx + radius, ry);
          context.quadraticCurveTo(rx, ry, rx, ry + radius);
          context.closePath();
        }
      }
    };
    CanvasMaskManager2.prototype.popMask = function(renderer) {
      renderer.context.restore();
      renderer.invalidateBlendMode();
    };
    CanvasMaskManager2.prototype.destroy = function() {
    };
    return CanvasMaskManager2;
  }()
);
function createColoredCanvas(color) {
  var canvas = settings.ADAPTER.createCanvas(6, 1);
  var context = canvas.getContext("2d");
  context.fillStyle = color;
  context.fillRect(0, 0, 6, 1);
  return canvas;
}
function canUseNewCanvasBlendModes() {
  if (typeof document === "undefined") {
    return false;
  }
  var magenta = createColoredCanvas("#ff00ff");
  var yellow = createColoredCanvas("#ffff00");
  var canvas = settings.ADAPTER.createCanvas(6, 1);
  var context = canvas.getContext("2d");
  context.globalCompositeOperation = "multiply";
  context.drawImage(magenta, 0, 0);
  context.drawImage(yellow, 2, 0);
  var imageData = context.getImageData(2, 0, 1, 1);
  if (!imageData) {
    return false;
  }
  var data = imageData.data;
  return data[0] === 255 && data[1] === 0 && data[2] === 0;
}
function mapCanvasBlendModesToPixi(array) {
  if (array === void 0) {
    array = [];
  }
  if (canUseNewCanvasBlendModes()) {
    array[BLEND_MODES.NORMAL] = "source-over";
    array[BLEND_MODES.ADD] = "lighter";
    array[BLEND_MODES.MULTIPLY] = "multiply";
    array[BLEND_MODES.SCREEN] = "screen";
    array[BLEND_MODES.OVERLAY] = "overlay";
    array[BLEND_MODES.DARKEN] = "darken";
    array[BLEND_MODES.LIGHTEN] = "lighten";
    array[BLEND_MODES.COLOR_DODGE] = "color-dodge";
    array[BLEND_MODES.COLOR_BURN] = "color-burn";
    array[BLEND_MODES.HARD_LIGHT] = "hard-light";
    array[BLEND_MODES.SOFT_LIGHT] = "soft-light";
    array[BLEND_MODES.DIFFERENCE] = "difference";
    array[BLEND_MODES.EXCLUSION] = "exclusion";
    array[BLEND_MODES.HUE] = "hue";
    array[BLEND_MODES.SATURATION] = "saturation";
    array[BLEND_MODES.COLOR] = "color";
    array[BLEND_MODES.LUMINOSITY] = "luminosity";
  } else {
    array[BLEND_MODES.NORMAL] = "source-over";
    array[BLEND_MODES.ADD] = "lighter";
    array[BLEND_MODES.MULTIPLY] = "source-over";
    array[BLEND_MODES.SCREEN] = "source-over";
    array[BLEND_MODES.OVERLAY] = "source-over";
    array[BLEND_MODES.DARKEN] = "source-over";
    array[BLEND_MODES.LIGHTEN] = "source-over";
    array[BLEND_MODES.COLOR_DODGE] = "source-over";
    array[BLEND_MODES.COLOR_BURN] = "source-over";
    array[BLEND_MODES.HARD_LIGHT] = "source-over";
    array[BLEND_MODES.SOFT_LIGHT] = "source-over";
    array[BLEND_MODES.DIFFERENCE] = "source-over";
    array[BLEND_MODES.EXCLUSION] = "source-over";
    array[BLEND_MODES.HUE] = "source-over";
    array[BLEND_MODES.SATURATION] = "source-over";
    array[BLEND_MODES.COLOR] = "source-over";
    array[BLEND_MODES.LUMINOSITY] = "source-over";
  }
  array[BLEND_MODES.NORMAL_NPM] = array[BLEND_MODES.NORMAL];
  array[BLEND_MODES.ADD_NPM] = array[BLEND_MODES.ADD];
  array[BLEND_MODES.SCREEN_NPM] = array[BLEND_MODES.SCREEN];
  array[BLEND_MODES.SRC_IN] = "source-in";
  array[BLEND_MODES.SRC_OUT] = "source-out";
  array[BLEND_MODES.SRC_ATOP] = "source-atop";
  array[BLEND_MODES.DST_OVER] = "destination-over";
  array[BLEND_MODES.DST_IN] = "destination-in";
  array[BLEND_MODES.DST_OUT] = "destination-out";
  array[BLEND_MODES.DST_ATOP] = "destination-atop";
  array[BLEND_MODES.XOR] = "xor";
  array[BLEND_MODES.SUBTRACT] = "source-over";
  return array;
}
var tempMatrix = new Matrix();
var CanvasRenderer = (
  /** @class */
  function(_super) {
    __extends(CanvasRenderer2, _super);
    function CanvasRenderer2(options) {
      var _this = _super.call(this, RENDERER_TYPE.CANVAS, options) || this;
      _this.refresh = true;
      _this.maskManager = new CanvasMaskManager(_this);
      _this.smoothProperty = "imageSmoothingEnabled";
      _this.blendModes = mapCanvasBlendModesToPixi();
      _this.renderingToScreen = false;
      _this._activeBlendMode = null;
      _this._projTransform = null;
      _this._outerBlend = false;
      _this.rootContext = _this.view.getContext("2d", { alpha: _this.useContextAlpha });
      _this.context = _this.rootContext;
      if (!_this.rootContext.imageSmoothingEnabled) {
        var rc = _this.rootContext;
        if (rc.webkitImageSmoothingEnabled) {
          _this.smoothProperty = "webkitImageSmoothingEnabled";
        } else if (rc.mozImageSmoothingEnabled) {
          _this.smoothProperty = "mozImageSmoothingEnabled";
        } else if (rc.oImageSmoothingEnabled) {
          _this.smoothProperty = "oImageSmoothingEnabled";
        } else if (rc.msImageSmoothingEnabled) {
          _this.smoothProperty = "msImageSmoothingEnabled";
        }
      }
      _this.initPlugins(CanvasRenderer2.__plugins);
      sayHello("Canvas");
      _this.resize(_this.options.width, _this.options.height);
      return _this;
    }
    CanvasRenderer2.prototype.addSystem = function() {
      return this;
    };
    CanvasRenderer2.prototype.render = function(displayObject, options) {
      if (!this.view) {
        return;
      }
      var renderTexture;
      var clear;
      var transform;
      var skipUpdateTransform;
      if (options) {
        if (options instanceof RenderTexture || options instanceof BaseRenderTexture) {
          deprecation("6.0.0", "CanvasRenderer#render arguments changed, use options instead.");
          renderTexture = options;
          clear = arguments[2];
          transform = arguments[3];
          skipUpdateTransform = arguments[4];
        } else {
          renderTexture = options.renderTexture;
          clear = options.clear;
          transform = options.transform;
          skipUpdateTransform = options.skipUpdateTransform;
        }
      }
      this.renderingToScreen = !renderTexture;
      this.emit("prerender");
      var rootResolution = this.resolution;
      if (renderTexture) {
        renderTexture = renderTexture.castToBaseTexture();
        if (!renderTexture._canvasRenderTarget) {
          renderTexture._canvasRenderTarget = new CanvasRenderTarget(renderTexture.width, renderTexture.height, renderTexture.resolution);
          renderTexture.resource = new CanvasResource(renderTexture._canvasRenderTarget.canvas);
          renderTexture.valid = true;
        }
        this.context = renderTexture._canvasRenderTarget.context;
        this.resolution = renderTexture._canvasRenderTarget.resolution;
      } else {
        this.context = this.rootContext;
      }
      var context = this.context;
      this._projTransform = transform || null;
      if (!renderTexture) {
        this._lastObjectRendered = displayObject;
      }
      if (!skipUpdateTransform) {
        var cacheParent = displayObject.enableTempParent();
        displayObject.updateTransform();
        displayObject.disableTempParent(cacheParent);
      }
      context.save();
      context.setTransform(1, 0, 0, 1, 0, 0);
      context.globalAlpha = 1;
      this._activeBlendMode = BLEND_MODES.NORMAL;
      this._outerBlend = false;
      context.globalCompositeOperation = this.blendModes[BLEND_MODES.NORMAL];
      if (clear !== void 0 ? clear : this.clearBeforeRender) {
        if (this.renderingToScreen) {
          context.clearRect(0, 0, this.width, this.height);
          if (this.backgroundAlpha > 0) {
            context.globalAlpha = this.useContextAlpha ? this.backgroundAlpha : 1;
            context.fillStyle = this._backgroundColorString;
            context.fillRect(0, 0, this.width, this.height);
            context.globalAlpha = 1;
          }
        } else {
          renderTexture = renderTexture;
          renderTexture._canvasRenderTarget.clear();
          var clearColor = renderTexture.clearColor;
          if (clearColor[3] > 0) {
            context.globalAlpha = this.useContextAlpha ? clearColor[3] : 1;
            context.fillStyle = hex2string(rgb2hex(clearColor));
            context.fillRect(0, 0, renderTexture.realWidth, renderTexture.realHeight);
            context.globalAlpha = 1;
          }
        }
      }
      var tempContext = this.context;
      this.context = context;
      displayObject.renderCanvas(this);
      this.context = tempContext;
      context.restore();
      this.resolution = rootResolution;
      this._projTransform = null;
      this.emit("postrender");
    };
    CanvasRenderer2.prototype.setContextTransform = function(transform, roundPixels, localResolution) {
      var mat = transform;
      var proj = this._projTransform;
      var resolution = this.resolution;
      localResolution = localResolution || resolution;
      if (proj) {
        mat = tempMatrix;
        mat.copyFrom(transform);
        mat.prepend(proj);
      }
      if (roundPixels) {
        this.context.setTransform(mat.a * localResolution, mat.b * localResolution, mat.c * localResolution, mat.d * localResolution, mat.tx * resolution | 0, mat.ty * resolution | 0);
      } else {
        this.context.setTransform(mat.a * localResolution, mat.b * localResolution, mat.c * localResolution, mat.d * localResolution, mat.tx * resolution, mat.ty * resolution);
      }
    };
    CanvasRenderer2.prototype.clear = function(clearColor, alpha) {
      if (clearColor === void 0) {
        clearColor = this._backgroundColorString;
      }
      if (alpha === void 0) {
        alpha = this.backgroundAlpha;
      }
      var context = this.context;
      context.clearRect(0, 0, this.width, this.height);
      if (clearColor) {
        context.globalAlpha = this.useContextAlpha ? alpha : 1;
        context.fillStyle = clearColor;
        context.fillRect(0, 0, this.width, this.height);
        context.globalAlpha = 1;
      }
    };
    CanvasRenderer2.prototype.setBlendMode = function(blendMode, readyForOuterBlend) {
      var outerBlend = blendMode === BLEND_MODES.SRC_IN || blendMode === BLEND_MODES.SRC_OUT || blendMode === BLEND_MODES.DST_IN || blendMode === BLEND_MODES.DST_ATOP;
      if (!readyForOuterBlend && outerBlend) {
        blendMode = BLEND_MODES.NORMAL;
      }
      if (this._activeBlendMode === blendMode) {
        return;
      }
      this._activeBlendMode = blendMode;
      this._outerBlend = outerBlend;
      this.context.globalCompositeOperation = this.blendModes[blendMode];
    };
    CanvasRenderer2.prototype.destroy = function(removeView) {
      _super.prototype.destroy.call(this, removeView);
      this.context = null;
      this.refresh = true;
      this.maskManager.destroy();
      this.maskManager = null;
      this.smoothProperty = null;
    };
    CanvasRenderer2.prototype.resize = function(desiredScreenWidth, desiredScreenHeight) {
      _super.prototype.resize.call(this, desiredScreenWidth, desiredScreenHeight);
      if (this.smoothProperty) {
        this.rootContext[this.smoothProperty] = settings.SCALE_MODE === SCALE_MODES.LINEAR;
      }
    };
    CanvasRenderer2.prototype.invalidateBlendMode = function() {
      this._activeBlendMode = this.blendModes.indexOf(this.context.globalCompositeOperation);
    };
    CanvasRenderer2.registerPlugin = function(pluginName, ctor) {
      deprecation("6.5.0", "CanvasRenderer.registerPlugin() has been deprecated, please use extensions.add() instead.");
      extensions.add({
        name: pluginName,
        type: ExtensionType.CanvasRendererPlugin,
        ref: ctor
      });
    };
    CanvasRenderer2.__plugins = {};
    return CanvasRenderer2;
  }(AbstractRenderer)
);
extensions.handleByMap(ExtensionType.CanvasRendererPlugin, CanvasRenderer.__plugins);
var canvasUtils = {
  canvas: null,
  /**
   * Basically this method just needs a sprite and a color and tints the sprite with the given color.
   * @memberof PIXI.canvasUtils
   * @param {PIXI.Sprite} sprite - the sprite to tint
   * @param sprite.texture
   * @param {number} color - the color to use to tint the sprite with
   * @returns {HTMLCanvasElement} The tinted canvas
   */
  getTintedCanvas: function(sprite, color) {
    var texture = sprite.texture;
    color = canvasUtils.roundColor(color);
    var stringColor = "#" + ("00000" + (color | 0).toString(16)).slice(-6);
    texture.tintCache = texture.tintCache || {};
    var cachedCanvas = texture.tintCache[stringColor];
    var canvas;
    if (cachedCanvas) {
      if (cachedCanvas.tintId === texture._updateID) {
        return texture.tintCache[stringColor];
      }
      canvas = texture.tintCache[stringColor];
    } else {
      canvas = settings.ADAPTER.createCanvas();
    }
    canvasUtils.tintMethod(texture, color, canvas);
    canvas.tintId = texture._updateID;
    if (canvasUtils.convertTintToImage) {
      var tintImage = new Image();
      tintImage.src = canvas.toDataURL();
      texture.tintCache[stringColor] = tintImage;
    } else {
      texture.tintCache[stringColor] = canvas;
    }
    return canvas;
  },
  /**
   * Basically this method just needs a sprite and a color and tints the sprite with the given color.
   * @memberof PIXI.canvasUtils
   * @param {PIXI.Texture} texture - the sprite to tint
   * @param {number} color - the color to use to tint the sprite with
   * @returns {HTMLCanvasElement} The tinted canvas
   */
  getTintedPattern: function(texture, color) {
    color = canvasUtils.roundColor(color);
    var stringColor = "#" + ("00000" + (color | 0).toString(16)).slice(-6);
    texture.patternCache = texture.patternCache || {};
    var pattern = texture.patternCache[stringColor];
    if (pattern && pattern.tintId === texture._updateID) {
      return pattern;
    }
    if (!canvasUtils.canvas) {
      canvasUtils.canvas = settings.ADAPTER.createCanvas();
    }
    canvasUtils.tintMethod(texture, color, canvasUtils.canvas);
    pattern = canvasUtils.canvas.getContext("2d").createPattern(canvasUtils.canvas, "repeat");
    pattern.tintId = texture._updateID;
    texture.patternCache[stringColor] = pattern;
    return pattern;
  },
  /**
   * Tint a texture using the 'multiply' operation.
   * @memberof PIXI.canvasUtils
   * @param {PIXI.Texture} texture - the texture to tint
   * @param {number} color - the color to use to tint the sprite with
   * @param {HTMLCanvasElement} canvas - the current canvas
   */
  tintWithMultiply: function(texture, color, canvas) {
    var context = canvas.getContext("2d");
    var crop = texture._frame.clone();
    var resolution = texture.baseTexture.resolution;
    crop.x *= resolution;
    crop.y *= resolution;
    crop.width *= resolution;
    crop.height *= resolution;
    canvas.width = Math.ceil(crop.width);
    canvas.height = Math.ceil(crop.height);
    context.save();
    context.fillStyle = "#" + ("00000" + (color | 0).toString(16)).slice(-6);
    context.fillRect(0, 0, crop.width, crop.height);
    context.globalCompositeOperation = "multiply";
    var source = texture.baseTexture.getDrawableSource();
    context.drawImage(source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
    context.globalCompositeOperation = "destination-atop";
    context.drawImage(source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
    context.restore();
  },
  /**
   * Tint a texture using the 'overlay' operation.
   * @memberof PIXI.canvasUtils
   * @param {PIXI.Texture} texture - the texture to tint
   * @param {number} color - the color to use to tint the sprite with
   * @param {HTMLCanvasElement} canvas - the current canvas
   */
  tintWithOverlay: function(texture, color, canvas) {
    var context = canvas.getContext("2d");
    var crop = texture._frame.clone();
    var resolution = texture.baseTexture.resolution;
    crop.x *= resolution;
    crop.y *= resolution;
    crop.width *= resolution;
    crop.height *= resolution;
    canvas.width = Math.ceil(crop.width);
    canvas.height = Math.ceil(crop.height);
    context.save();
    context.globalCompositeOperation = "copy";
    context.fillStyle = "#" + ("00000" + (color | 0).toString(16)).slice(-6);
    context.fillRect(0, 0, crop.width, crop.height);
    context.globalCompositeOperation = "destination-atop";
    context.drawImage(texture.baseTexture.getDrawableSource(), crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
    context.restore();
  },
  /**
   * Tint a texture pixel per pixel.
   * @memberof PIXI.canvasUtils
   * @param {PIXI.Texture} texture - the texture to tint
   * @param {number} color - the color to use to tint the sprite with
   * @param {HTMLCanvasElement} canvas - the current canvas
   */
  tintWithPerPixel: function(texture, color, canvas) {
    var context = canvas.getContext("2d");
    var crop = texture._frame.clone();
    var resolution = texture.baseTexture.resolution;
    crop.x *= resolution;
    crop.y *= resolution;
    crop.width *= resolution;
    crop.height *= resolution;
    canvas.width = Math.ceil(crop.width);
    canvas.height = Math.ceil(crop.height);
    context.save();
    context.globalCompositeOperation = "copy";
    context.drawImage(texture.baseTexture.getDrawableSource(), crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
    context.restore();
    var rgbValues = hex2rgb(color);
    var r = rgbValues[0];
    var g = rgbValues[1];
    var b = rgbValues[2];
    var pixelData = context.getImageData(0, 0, crop.width, crop.height);
    var pixels = pixelData.data;
    for (var i = 0; i < pixels.length; i += 4) {
      pixels[i + 0] *= r;
      pixels[i + 1] *= g;
      pixels[i + 2] *= b;
    }
    context.putImageData(pixelData, 0, 0);
  },
  /**
   * Rounds the specified color according to the canvasUtils.cacheStepsPerColorChannel.
   * @memberof PIXI.canvasUtils
   * @param {number} color - the color to round, should be a hex color
   * @returns {number} The rounded color.
   */
  roundColor: function(color) {
    var step = canvasUtils.cacheStepsPerColorChannel;
    var rgbValues = hex2rgb(color);
    rgbValues[0] = Math.min(255, rgbValues[0] / step * step);
    rgbValues[1] = Math.min(255, rgbValues[1] / step * step);
    rgbValues[2] = Math.min(255, rgbValues[2] / step * step);
    return rgb2hex(rgbValues);
  },
  /**
   * Number of steps which will be used as a cap when rounding colors.
   * @memberof PIXI.canvasUtils
   * @type {number}
   */
  cacheStepsPerColorChannel: 8,
  /**
   * Tint cache boolean flag.
   * @memberof PIXI.canvasUtils
   * @type {boolean}
   */
  convertTintToImage: false,
  /**
   * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.
   * @memberof PIXI.canvasUtils
   * @type {boolean}
   */
  canUseMultiply: canUseNewCanvasBlendModes(),
  /**
   * The tinting method that will be used.
   * @memberof PIXI.canvasUtils
   * @type {Function}
   */
  tintMethod: null
};
canvasUtils.tintMethod = canvasUtils.canUseMultiply ? canvasUtils.tintWithMultiply : canvasUtils.tintWithPerPixel;
var parentCreate = Renderer.create;
Renderer.create = function create(options) {
  var forceCanvas = options && options.forceCanvas;
  if (!forceCanvas) {
    try {
      return parentCreate(options);
    } catch (err) {
    }
  }
  return new CanvasRenderer(options);
};
BaseTexture.prototype.getDrawableSource = function getDrawableSource() {
  var resource = this.resource;
  return resource ? resource.bitmap || resource.source : null;
};
BaseRenderTexture.prototype._canvasRenderTarget = null;
Texture.prototype.patternCache = null;
Texture.prototype.tintCache = null;

// node_modules/@pixi/canvas-mesh/dist/esm/canvas-mesh.mjs
var CanvasMeshRenderer = (
  /** @class */
  function() {
    function CanvasMeshRenderer2(renderer) {
      this.renderer = renderer;
    }
    CanvasMeshRenderer2.prototype.render = function(mesh) {
      var renderer = this.renderer;
      var transform = mesh.worldTransform;
      renderer.context.globalAlpha = mesh.worldAlpha;
      renderer.setBlendMode(mesh.blendMode);
      renderer.setContextTransform(transform, mesh.roundPixels);
      if (mesh.drawMode !== DRAW_MODES.TRIANGLES) {
        this._renderTriangleMesh(mesh);
      } else {
        this._renderTriangles(mesh);
      }
    };
    CanvasMeshRenderer2.prototype._renderTriangleMesh = function(mesh) {
      var length = mesh.geometry.buffers[0].data.length;
      for (var i = 0; i < length - 2; i++) {
        var index = i * 2;
        this._renderDrawTriangle(mesh, index, index + 2, index + 4);
      }
    };
    CanvasMeshRenderer2.prototype._renderTriangles = function(mesh) {
      var indices = mesh.geometry.getIndex().data;
      var length = indices.length;
      for (var i = 0; i < length; i += 3) {
        var index0 = indices[i] * 2;
        var index1 = indices[i + 1] * 2;
        var index2 = indices[i + 2] * 2;
        this._renderDrawTriangle(mesh, index0, index1, index2);
      }
    };
    CanvasMeshRenderer2.prototype._renderDrawTriangle = function(mesh, index0, index1, index2) {
      var context = this.renderer.context;
      var vertices = mesh.geometry.buffers[0].data;
      var uvs = mesh.uvs, texture = mesh.texture;
      if (!texture.valid) {
        return;
      }
      var isTinted = mesh.tint !== 16777215;
      var base = texture.baseTexture;
      var textureWidth = base.width;
      var textureHeight = base.height;
      if (isTinted) {
        if (mesh._cachedTint !== mesh.tint) {
          mesh._cachedTint = mesh.tint;
          mesh._cachedTexture = mesh._cachedTexture || new Texture(base);
          mesh._tintedCanvas = canvasUtils.getTintedCanvas({ texture: mesh._cachedTexture }, mesh.tint);
        }
      }
      var textureSource = isTinted ? mesh._tintedCanvas : base.getDrawableSource();
      var u0 = uvs[index0] * base.width;
      var u1 = uvs[index1] * base.width;
      var u2 = uvs[index2] * base.width;
      var v0 = uvs[index0 + 1] * base.height;
      var v1 = uvs[index1 + 1] * base.height;
      var v2 = uvs[index2 + 1] * base.height;
      var x0 = vertices[index0];
      var x1 = vertices[index1];
      var x2 = vertices[index2];
      var y0 = vertices[index0 + 1];
      var y1 = vertices[index1 + 1];
      var y2 = vertices[index2 + 1];
      var screenPadding = mesh.canvasPadding / this.renderer.resolution;
      if (screenPadding > 0) {
        var _a = mesh.worldTransform, a = _a.a, b = _a.b, c = _a.c, d = _a.d;
        var centerX = (x0 + x1 + x2) / 3;
        var centerY = (y0 + y1 + y2) / 3;
        var normX = x0 - centerX;
        var normY = y0 - centerY;
        var screenX = a * normX + c * normY;
        var screenY = b * normX + d * normY;
        var screenDist = Math.sqrt(screenX * screenX + screenY * screenY);
        var paddingFactor = 1 + screenPadding / screenDist;
        x0 = centerX + normX * paddingFactor;
        y0 = centerY + normY * paddingFactor;
        normX = x1 - centerX;
        normY = y1 - centerY;
        screenX = a * normX + c * normY;
        screenY = b * normX + d * normY;
        screenDist = Math.sqrt(screenX * screenX + screenY * screenY);
        paddingFactor = 1 + screenPadding / screenDist;
        x1 = centerX + normX * paddingFactor;
        y1 = centerY + normY * paddingFactor;
        normX = x2 - centerX;
        normY = y2 - centerY;
        screenX = a * normX + c * normY;
        screenY = b * normX + d * normY;
        screenDist = Math.sqrt(screenX * screenX + screenY * screenY);
        paddingFactor = 1 + screenPadding / screenDist;
        x2 = centerX + normX * paddingFactor;
        y2 = centerY + normY * paddingFactor;
      }
      context.save();
      context.beginPath();
      context.moveTo(x0, y0);
      context.lineTo(x1, y1);
      context.lineTo(x2, y2);
      context.closePath();
      context.clip();
      var delta = u0 * v1 + v0 * u2 + u1 * v2 - v1 * u2 - v0 * u1 - u0 * v2;
      var deltaA = x0 * v1 + v0 * x2 + x1 * v2 - v1 * x2 - v0 * x1 - x0 * v2;
      var deltaB = u0 * x1 + x0 * u2 + u1 * x2 - x1 * u2 - x0 * u1 - u0 * x2;
      var deltaC = u0 * v1 * x2 + v0 * x1 * u2 + x0 * u1 * v2 - x0 * v1 * u2 - v0 * u1 * x2 - u0 * x1 * v2;
      var deltaD = y0 * v1 + v0 * y2 + y1 * v2 - v1 * y2 - v0 * y1 - y0 * v2;
      var deltaE = u0 * y1 + y0 * u2 + u1 * y2 - y1 * u2 - y0 * u1 - u0 * y2;
      var deltaF = u0 * v1 * y2 + v0 * y1 * u2 + y0 * u1 * v2 - y0 * v1 * u2 - v0 * u1 * y2 - u0 * y1 * v2;
      context.transform(deltaA / delta, deltaD / delta, deltaB / delta, deltaE / delta, deltaC / delta, deltaF / delta);
      context.drawImage(textureSource, 0, 0, textureWidth * base.resolution, textureHeight * base.resolution, 0, 0, textureWidth, textureHeight);
      context.restore();
      this.renderer.invalidateBlendMode();
    };
    CanvasMeshRenderer2.prototype.renderMeshFlat = function(mesh) {
      var context = this.renderer.context;
      var vertices = mesh.geometry.getBuffer("aVertexPosition").data;
      var length = vertices.length / 2;
      context.beginPath();
      for (var i = 1; i < length - 2; ++i) {
        var index = i * 2;
        var x0 = vertices[index];
        var y0 = vertices[index + 1];
        var x1 = vertices[index + 2];
        var y1 = vertices[index + 3];
        var x2 = vertices[index + 4];
        var y2 = vertices[index + 5];
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
      }
      context.fillStyle = "#FF0000";
      context.fill();
      context.closePath();
    };
    CanvasMeshRenderer2.prototype.destroy = function() {
      this.renderer = null;
    };
    CanvasMeshRenderer2.extension = {
      name: "mesh",
      type: ExtensionType.CanvasRendererPlugin
    };
    return CanvasMeshRenderer2;
  }()
);
settings.MESH_CANVAS_PADDING = 0;
MeshMaterial.prototype._renderCanvas = function _renderCanvas(renderer, mesh) {
  renderer.plugins.mesh.render(mesh);
};
NineSlicePlane.prototype._cachedTint = 16777215;
NineSlicePlane.prototype._tintedCanvas = null;
NineSlicePlane.prototype._canvasUvs = null;
NineSlicePlane.prototype._renderCanvas = function _renderCanvas2(renderer) {
  var context = renderer.context;
  var transform = this.worldTransform;
  var isTinted = this.tint !== 16777215;
  var texture = this.texture;
  if (!texture.valid) {
    return;
  }
  if (isTinted) {
    if (this._cachedTint !== this.tint) {
      this._cachedTint = this.tint;
      this._tintedCanvas = canvasUtils.getTintedCanvas(this, this.tint);
    }
  }
  var textureSource = !isTinted ? texture.baseTexture.getDrawableSource() : this._tintedCanvas;
  if (!this._canvasUvs) {
    this._canvasUvs = [0, 0, 0, 0, 0, 0, 0, 0];
  }
  var vertices = this.vertices;
  var uvs = this._canvasUvs;
  var u0 = isTinted ? 0 : texture.frame.x;
  var v0 = isTinted ? 0 : texture.frame.y;
  var u1 = u0 + texture.frame.width;
  var v1 = v0 + texture.frame.height;
  uvs[0] = u0;
  uvs[1] = u0 + this._leftWidth;
  uvs[2] = u1 - this._rightWidth;
  uvs[3] = u1;
  uvs[4] = v0;
  uvs[5] = v0 + this._topHeight;
  uvs[6] = v1 - this._bottomHeight;
  uvs[7] = v1;
  for (var i = 0; i < 8; i++) {
    uvs[i] *= texture.baseTexture.resolution;
  }
  context.globalAlpha = this.worldAlpha;
  renderer.setBlendMode(this.blendMode);
  renderer.setContextTransform(transform, this.roundPixels);
  for (var row = 0; row < 3; row++) {
    for (var col = 0; col < 3; col++) {
      var ind = col * 2 + row * 8;
      var sw = Math.max(1, uvs[col + 1] - uvs[col]);
      var sh = Math.max(1, uvs[row + 5] - uvs[row + 4]);
      var dw = Math.max(1, vertices[ind + 10] - vertices[ind]);
      var dh = Math.max(1, vertices[ind + 11] - vertices[ind + 1]);
      context.drawImage(textureSource, uvs[col], uvs[row + 4], sw, sh, vertices[ind], vertices[ind + 1], dw, dh);
    }
  }
};
var warned = false;
Mesh.prototype._cachedTint = 16777215;
Mesh.prototype._tintedCanvas = null;
Mesh.prototype._cachedTexture = null;
Mesh.prototype._renderCanvas = function _renderCanvas3(renderer) {
  if (this.shader.uvMatrix) {
    this.shader.uvMatrix.update();
    this.calculateUvs();
  }
  if (this.material._renderCanvas) {
    this.material._renderCanvas(renderer, this);
  } else if (!warned) {
    warned = true;
    if (globalThis.console) {
      console.warn("Mesh with custom shaders are not supported in CanvasRenderer.");
    }
  }
};
Mesh.prototype._canvasPadding = null;
Object.defineProperty(Mesh.prototype, "canvasPadding", {
  get: function() {
    return this._canvasPadding !== null ? this._canvasPadding : settings.MESH_CANVAS_PADDING;
  },
  set: function(value) {
    this._canvasPadding = value;
  }
});
SimpleMesh.prototype._renderCanvas = function _renderCanvas4(renderer) {
  if (this.autoUpdate) {
    this.geometry.getBuffer("aVertexPosition").update();
  }
  if (this.shader.update) {
    this.shader.update();
  }
  this.calculateUvs();
  this.material._renderCanvas(renderer, this);
};
SimpleRope.prototype._renderCanvas = function _renderCanvas5(renderer) {
  if (this.autoUpdate || this.geometry._width !== this.shader.texture.height) {
    this.geometry._width = this.shader.texture.height;
    this.geometry.update();
  }
  if (this.shader.update) {
    this.shader.update();
  }
  this.calculateUvs();
  this.material._renderCanvas(renderer, this);
};

// node_modules/@pixi/canvas-graphics/dist/esm/canvas-graphics.mjs
var PolygonUtils = (
  /** @class */
  function() {
    function PolygonUtils2() {
    }
    PolygonUtils2.offsetPolygon = function(points, offset) {
      var offsetPoints = [];
      var length = points.length;
      offset = PolygonUtils2.isPolygonClockwise(points) ? offset : -1 * offset;
      for (var j = 0; j < length; j += 2) {
        var i = j - 2;
        if (i < 0) {
          i += length;
        }
        var k = (j + 2) % length;
        var v1x = points[j] - points[i];
        var v1y = points[j + 1] - points[i + 1];
        var len = Math.sqrt(v1x * v1x + v1y * v1y);
        v1x /= len;
        v1y /= len;
        v1x *= offset;
        v1y *= offset;
        var norm1x = -v1y;
        var norm1y = v1x;
        var pij1 = [points[i] + norm1x, points[i + 1] + norm1y];
        var pij2 = [points[j] + norm1x, points[j + 1] + norm1y];
        var v2x = points[k] - points[j];
        var v2y = points[k + 1] - points[j + 1];
        len = Math.sqrt(v2x * v2x + v2y * v2y);
        v2x /= len;
        v2y /= len;
        v2x *= offset;
        v2y *= offset;
        var norm2x = -v2y;
        var norm2y = v2x;
        var pjk1 = [points[j] + norm2x, points[j + 1] + norm2y];
        var pjk2 = [points[k] + norm2x, points[k + 1] + norm2y];
        var intersectPoint = PolygonUtils2.findIntersection(pij1[0], pij1[1], pij2[0], pij2[1], pjk1[0], pjk1[1], pjk2[0], pjk2[1]);
        if (intersectPoint) {
          offsetPoints.push.apply(offsetPoints, intersectPoint);
        }
      }
      return offsetPoints;
    };
    PolygonUtils2.findIntersection = function(x1, y1, x2, y2, x3, y3, x4, y4) {
      var denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
      var numeratorA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
      var numeratorB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
      if (denominator === 0) {
        if (numeratorA === 0 && numeratorB === 0) {
          return [(x1 + x2) / 2, (y1 + y2) / 2];
        }
        return null;
      }
      var uA = numeratorA / denominator;
      return [x1 + uA * (x2 - x1), y1 + uA * (y2 - y1)];
    };
    PolygonUtils2.isPolygonClockwise = function(polygon) {
      var sum = 0;
      for (var i = 0, j = polygon.length - 2; i < polygon.length; j = i, i += 2) {
        sum += (polygon[i] - polygon[j]) * (polygon[i + 1] + polygon[j + 1]);
      }
      return sum > 0;
    };
    return PolygonUtils2;
  }()
);
var CanvasGraphicsRenderer = (
  /** @class */
  function() {
    function CanvasGraphicsRenderer2(renderer) {
      this._svgMatrix = null;
      this._tempMatrix = new Matrix();
      this.renderer = renderer;
    }
    CanvasGraphicsRenderer2.prototype._calcCanvasStyle = function(style, tint) {
      var res;
      if (style.texture && style.texture.baseTexture !== Texture.WHITE.baseTexture) {
        if (style.texture.valid) {
          res = canvasUtils.getTintedPattern(style.texture, tint);
          this.setPatternTransform(res, style.matrix || Matrix.IDENTITY);
        } else {
          res = "#808080";
        }
      } else {
        res = "#" + ("00000" + (tint | 0).toString(16)).slice(-6);
      }
      return res;
    };
    CanvasGraphicsRenderer2.prototype.render = function(graphics) {
      var renderer = this.renderer;
      var context = renderer.context;
      var worldAlpha = graphics.worldAlpha;
      var transform = graphics.transform.worldTransform;
      renderer.setContextTransform(transform);
      renderer.setBlendMode(graphics.blendMode);
      var graphicsData = graphics.geometry.graphicsData;
      var contextFillStyle;
      var contextStrokeStyle;
      var tintR = (graphics.tint >> 16 & 255) / 255;
      var tintG = (graphics.tint >> 8 & 255) / 255;
      var tintB = (graphics.tint & 255) / 255;
      for (var i = 0; i < graphicsData.length; i++) {
        var data = graphicsData[i];
        var shape = data.shape;
        var fillStyle = data.fillStyle;
        var lineStyle = data.lineStyle;
        var fillColor = data.fillStyle.color | 0;
        var lineColor = data.lineStyle.color | 0;
        if (data.matrix) {
          renderer.setContextTransform(transform.copyTo(this._tempMatrix).append(data.matrix));
        }
        if (fillStyle.visible) {
          var fillTint = ((fillColor >> 16 & 255) / 255 * tintR * 255 << 16) + ((fillColor >> 8 & 255) / 255 * tintG * 255 << 8) + (fillColor & 255) / 255 * tintB * 255;
          contextFillStyle = this._calcCanvasStyle(fillStyle, fillTint);
        }
        if (lineStyle.visible) {
          var lineTint = ((lineColor >> 16 & 255) / 255 * tintR * 255 << 16) + ((lineColor >> 8 & 255) / 255 * tintG * 255 << 8) + (lineColor & 255) / 255 * tintB * 255;
          contextStrokeStyle = this._calcCanvasStyle(lineStyle, lineTint);
        }
        context.lineWidth = lineStyle.width;
        context.lineCap = lineStyle.cap;
        context.lineJoin = lineStyle.join;
        context.miterLimit = lineStyle.miterLimit;
        if (data.type === SHAPES.POLY) {
          context.beginPath();
          var tempShape = shape;
          var points = tempShape.points;
          var holes = data.holes;
          var outerArea = void 0;
          var innerArea = void 0;
          var px = void 0;
          var py = void 0;
          var holesDirection = void 0;
          context.moveTo(points[0], points[1]);
          for (var j = 2; j < points.length; j += 2) {
            context.lineTo(points[j], points[j + 1]);
          }
          if (tempShape.closeStroke) {
            context.closePath();
          }
          if (holes.length > 0) {
            holesDirection = [];
            outerArea = 0;
            px = points[0];
            py = points[1];
            for (var j = 2; j + 2 < points.length; j += 2) {
              outerArea += (points[j] - px) * (points[j + 3] - py) - (points[j + 2] - px) * (points[j + 1] - py);
            }
            for (var k = 0; k < holes.length; k++) {
              points = holes[k].shape.points;
              if (!points) {
                continue;
              }
              innerArea = 0;
              px = points[0];
              py = points[1];
              for (var j = 2; j + 2 < points.length; j += 2) {
                innerArea += (points[j] - px) * (points[j + 3] - py) - (points[j + 2] - px) * (points[j + 1] - py);
              }
              if (innerArea * outerArea < 0) {
                context.moveTo(points[0], points[1]);
                for (var j = 2; j < points.length; j += 2) {
                  context.lineTo(points[j], points[j + 1]);
                }
              } else {
                context.moveTo(points[points.length - 2], points[points.length - 1]);
                for (var j = points.length - 4; j >= 0; j -= 2) {
                  context.lineTo(points[j], points[j + 1]);
                }
              }
              if (holes[k].shape.closeStroke) {
                context.closePath();
              }
              holesDirection[k] = innerArea * outerArea < 0;
            }
          }
          if (fillStyle.visible) {
            context.globalAlpha = fillStyle.alpha * worldAlpha;
            context.fillStyle = contextFillStyle;
            context.fill();
          }
          if (lineStyle.visible) {
            this.paintPolygonStroke(tempShape, lineStyle, contextStrokeStyle, holes, holesDirection, worldAlpha, context);
          }
        } else if (data.type === SHAPES.RECT) {
          var tempShape = shape;
          if (fillStyle.visible) {
            context.globalAlpha = fillStyle.alpha * worldAlpha;
            context.fillStyle = contextFillStyle;
            context.fillRect(tempShape.x, tempShape.y, tempShape.width, tempShape.height);
          }
          if (lineStyle.visible) {
            var alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));
            var width = tempShape.width + 2 * alignmentOffset;
            var height = tempShape.height + 2 * alignmentOffset;
            context.globalAlpha = lineStyle.alpha * worldAlpha;
            context.strokeStyle = contextStrokeStyle;
            context.strokeRect(tempShape.x - alignmentOffset, tempShape.y - alignmentOffset, width, height);
          }
        } else if (data.type === SHAPES.CIRC) {
          var tempShape = shape;
          context.beginPath();
          context.arc(tempShape.x, tempShape.y, tempShape.radius, 0, 2 * Math.PI);
          context.closePath();
          if (fillStyle.visible) {
            context.globalAlpha = fillStyle.alpha * worldAlpha;
            context.fillStyle = contextFillStyle;
            context.fill();
          }
          if (lineStyle.visible) {
            if (lineStyle.alignment !== 0.5) {
              var alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));
              context.beginPath();
              context.arc(tempShape.x, tempShape.y, tempShape.radius + alignmentOffset, 0, 2 * Math.PI);
              context.closePath();
            }
            context.globalAlpha = lineStyle.alpha * worldAlpha;
            context.strokeStyle = contextStrokeStyle;
            context.stroke();
          }
        } else if (data.type === SHAPES.ELIP) {
          var tempShape = shape;
          var drawShapeOverStroke = lineStyle.alignment === 1;
          if (!drawShapeOverStroke) {
            this.paintEllipse(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);
          }
          if (lineStyle.visible) {
            if (lineStyle.alignment !== 0.5) {
              var kappa = 0.5522848;
              var alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));
              var sW = (tempShape.width + alignmentOffset) * 2;
              var sH = (tempShape.height + alignmentOffset) * 2;
              var sX = tempShape.x - sW / 2;
              var sY = tempShape.y - sH / 2;
              var sOx = sW / 2 * kappa;
              var sOy = sH / 2 * kappa;
              var sXe = sX + sW;
              var sYe = sY + sH;
              var sXm = sX + sW / 2;
              var sYm = sY + sH / 2;
              context.beginPath();
              context.moveTo(sX, sYm);
              context.bezierCurveTo(sX, sYm - sOy, sXm - sOx, sY, sXm, sY);
              context.bezierCurveTo(sXm + sOx, sY, sXe, sYm - sOy, sXe, sYm);
              context.bezierCurveTo(sXe, sYm + sOy, sXm + sOx, sYe, sXm, sYe);
              context.bezierCurveTo(sXm - sOx, sYe, sX, sYm + sOy, sX, sYm);
              context.closePath();
            }
            context.globalAlpha = lineStyle.alpha * worldAlpha;
            context.strokeStyle = contextStrokeStyle;
            context.stroke();
          }
          if (drawShapeOverStroke) {
            this.paintEllipse(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);
          }
        } else if (data.type === SHAPES.RREC) {
          var tempShape = shape;
          var drawShapeOverStroke = lineStyle.alignment === 1;
          if (!drawShapeOverStroke) {
            this.paintRoundedRectangle(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);
          }
          if (lineStyle.visible) {
            if (lineStyle.alignment !== 0.5) {
              var width = tempShape.width;
              var height = tempShape.height;
              var alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));
              var sRx = tempShape.x - alignmentOffset;
              var sRy = tempShape.y - alignmentOffset;
              var sWidth = tempShape.width + 2 * alignmentOffset;
              var sHeight = tempShape.height + 2 * alignmentOffset;
              var radiusOffset = alignmentOffset * (lineStyle.alignment >= 1 ? Math.min(sWidth / width, sHeight / height) : Math.min(width / sWidth, height / sHeight));
              var sRadius = tempShape.radius + radiusOffset;
              var sMaxRadius = Math.min(sWidth, sHeight) / 2;
              sRadius = sRadius > sMaxRadius ? sMaxRadius : sRadius;
              context.beginPath();
              context.moveTo(sRx, sRy + sRadius);
              context.lineTo(sRx, sRy + sHeight - sRadius);
              context.quadraticCurveTo(sRx, sRy + sHeight, sRx + sRadius, sRy + sHeight);
              context.lineTo(sRx + sWidth - sRadius, sRy + sHeight);
              context.quadraticCurveTo(sRx + sWidth, sRy + sHeight, sRx + sWidth, sRy + sHeight - sRadius);
              context.lineTo(sRx + sWidth, sRy + sRadius);
              context.quadraticCurveTo(sRx + sWidth, sRy, sRx + sWidth - sRadius, sRy);
              context.lineTo(sRx + sRadius, sRy);
              context.quadraticCurveTo(sRx, sRy, sRx, sRy + sRadius);
              context.closePath();
            }
            context.globalAlpha = lineStyle.alpha * worldAlpha;
            context.strokeStyle = contextStrokeStyle;
            context.stroke();
          }
          if (drawShapeOverStroke) {
            this.paintRoundedRectangle(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);
          }
        }
      }
    };
    CanvasGraphicsRenderer2.prototype.paintPolygonStroke = function(shape, lineStyle, contextStrokeStyle, holes, holesDirection, worldAlpha, context) {
      if (lineStyle.alignment !== 0.5) {
        var alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));
        var offsetPoints = PolygonUtils.offsetPolygon(shape.points, alignmentOffset);
        var points = void 0;
        context.beginPath();
        context.moveTo(offsetPoints[0], offsetPoints[1]);
        for (var j = 2; j < offsetPoints.length; j += 2) {
          context.lineTo(offsetPoints[j], offsetPoints[j + 1]);
        }
        if (shape.closeStroke) {
          context.closePath();
        }
        for (var k = 0; k < holes.length; k++) {
          points = holes[k].shape.points;
          offsetPoints = PolygonUtils.offsetPolygon(points, alignmentOffset);
          if (holesDirection[k]) {
            context.moveTo(offsetPoints[0], offsetPoints[1]);
            for (var j = 2; j < offsetPoints.length; j += 2) {
              context.lineTo(offsetPoints[j], offsetPoints[j + 1]);
            }
          } else {
            context.moveTo(offsetPoints[offsetPoints.length - 2], offsetPoints[offsetPoints.length - 1]);
            for (var j = offsetPoints.length - 4; j >= 0; j -= 2) {
              context.lineTo(offsetPoints[j], offsetPoints[j + 1]);
            }
          }
          if (holes[k].shape.closeStroke) {
            context.closePath();
          }
        }
      }
      context.globalAlpha = lineStyle.alpha * worldAlpha;
      context.strokeStyle = contextStrokeStyle;
      context.stroke();
    };
    CanvasGraphicsRenderer2.prototype.paintEllipse = function(shape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context) {
      var w = shape.width * 2;
      var h = shape.height * 2;
      var x = shape.x - w / 2;
      var y = shape.y - h / 2;
      var kappa = 0.5522848;
      var ox = w / 2 * kappa;
      var oy = h / 2 * kappa;
      var xe = x + w;
      var ye = y + h;
      var xm = x + w / 2;
      var ym = y + h / 2;
      if (lineStyle.alignment === 0) {
        context.save();
      }
      context.beginPath();
      context.moveTo(x, ym);
      context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
      context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
      context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
      context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
      context.closePath();
      if (lineStyle.alignment === 0) {
        context.clip();
      }
      if (fillStyle.visible) {
        context.globalAlpha = fillStyle.alpha * worldAlpha;
        context.fillStyle = contextFillStyle;
        context.fill();
      }
      if (lineStyle.alignment === 0) {
        context.restore();
      }
    };
    CanvasGraphicsRenderer2.prototype.paintRoundedRectangle = function(shape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context) {
      var rx = shape.x;
      var ry = shape.y;
      var width = shape.width;
      var height = shape.height;
      var radius = shape.radius;
      var maxRadius = Math.min(width, height) / 2;
      radius = radius > maxRadius ? maxRadius : radius;
      if (lineStyle.alignment === 0) {
        context.save();
      }
      context.beginPath();
      context.moveTo(rx, ry + radius);
      context.lineTo(rx, ry + height - radius);
      context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
      context.lineTo(rx + width - radius, ry + height);
      context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
      context.lineTo(rx + width, ry + radius);
      context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
      context.lineTo(rx + radius, ry);
      context.quadraticCurveTo(rx, ry, rx, ry + radius);
      context.closePath();
      if (lineStyle.alignment === 0) {
        context.clip();
      }
      if (fillStyle.visible) {
        context.globalAlpha = fillStyle.alpha * worldAlpha;
        context.fillStyle = contextFillStyle;
        context.fill();
      }
      if (lineStyle.alignment === 0) {
        context.restore();
      }
    };
    CanvasGraphicsRenderer2.prototype.setPatternTransform = function(pattern, matrix) {
      if (this._svgMatrix === false) {
        return;
      }
      if (!this._svgMatrix) {
        var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        if (svg && svg.createSVGMatrix) {
          this._svgMatrix = svg.createSVGMatrix();
        }
        if (!this._svgMatrix || !pattern.setTransform) {
          this._svgMatrix = false;
          return;
        }
      }
      this._svgMatrix.a = matrix.a;
      this._svgMatrix.b = matrix.b;
      this._svgMatrix.c = matrix.c;
      this._svgMatrix.d = matrix.d;
      this._svgMatrix.e = matrix.tx;
      this._svgMatrix.f = matrix.ty;
      pattern.setTransform(this._svgMatrix.inverse());
    };
    CanvasGraphicsRenderer2.prototype.destroy = function() {
      this.renderer = null;
      this._svgMatrix = null;
      this._tempMatrix = null;
    };
    CanvasGraphicsRenderer2.extension = {
      name: "graphics",
      type: ExtensionType.CanvasRendererPlugin
    };
    return CanvasGraphicsRenderer2;
  }()
);
var canvasRenderer;
var tempMatrix2 = new Matrix();
Graphics.prototype.generateCanvasTexture = function generateCanvasTexture(scaleMode, resolution) {
  if (resolution === void 0) {
    resolution = 1;
  }
  var bounds = this.getLocalBounds();
  var canvasBuffer = RenderTexture.create({
    width: bounds.width,
    height: bounds.height,
    scaleMode,
    resolution
  });
  if (!canvasRenderer) {
    canvasRenderer = new CanvasRenderer();
  }
  this.transform.updateLocalTransform();
  this.transform.localTransform.copyTo(tempMatrix2);
  tempMatrix2.invert();
  tempMatrix2.tx -= bounds.x;
  tempMatrix2.ty -= bounds.y;
  canvasRenderer.render(this, { renderTexture: canvasBuffer, clear: true, transform: tempMatrix2 });
  var texture = Texture.from(canvasBuffer.baseTexture._canvasRenderTarget.canvas, {
    scaleMode
  });
  texture.baseTexture.setResolution(resolution);
  return texture;
};
Graphics.prototype.cachedGraphicsData = [];
Graphics.prototype._renderCanvas = function _renderCanvas6(renderer) {
  if (this.isMask === true) {
    return;
  }
  this.finishPoly();
  renderer.plugins.graphics.render(this);
};

// node_modules/@pixi/canvas-sprite/dist/esm/canvas-sprite.mjs
var canvasRenderWorldTransform = new Matrix();
var CanvasSpriteRenderer = (
  /** @class */
  function() {
    function CanvasSpriteRenderer2(renderer) {
      this.renderer = renderer;
    }
    CanvasSpriteRenderer2.prototype.render = function(sprite) {
      var texture = sprite._texture;
      var renderer = this.renderer;
      var context = renderer.context;
      if (!texture.valid) {
        return;
      }
      var sourceWidth = texture._frame.width;
      var sourceHeight = texture._frame.height;
      var destWidth = texture._frame.width;
      var destHeight = texture._frame.height;
      if (texture.trim) {
        if (groupD8.isVertical(texture.rotate)) {
          destWidth = texture.trim.height;
          destHeight = texture.trim.width;
        } else {
          destWidth = texture.trim.width;
          destHeight = texture.trim.height;
        }
      }
      var wt = sprite.transform.worldTransform;
      var dx = 0;
      var dy = 0;
      var source = texture.baseTexture.getDrawableSource();
      if (texture.orig.width <= 0 || texture.orig.height <= 0 || !texture.valid || !source) {
        return;
      }
      renderer.setBlendMode(sprite.blendMode, true);
      renderer.context.globalAlpha = sprite.worldAlpha;
      var smoothingEnabled = texture.baseTexture.scaleMode === SCALE_MODES.LINEAR;
      if (renderer.smoothProperty && renderer.context[renderer.smoothProperty] !== smoothingEnabled) {
        context[renderer.smoothProperty] = smoothingEnabled;
      }
      if (texture.trim) {
        dx = texture.trim.width / 2 + texture.trim.x - sprite.anchor.x * texture.orig.width;
        dy = texture.trim.height / 2 + texture.trim.y - sprite.anchor.y * texture.orig.height;
      } else {
        dx = (0.5 - sprite.anchor.x) * texture.orig.width;
        dy = (0.5 - sprite.anchor.y) * texture.orig.height;
      }
      if (texture.rotate) {
        wt.copyTo(canvasRenderWorldTransform);
        wt = canvasRenderWorldTransform;
        groupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy);
        dx = 0;
        dy = 0;
      }
      dx -= destWidth / 2;
      dy -= destHeight / 2;
      renderer.setContextTransform(wt, sprite.roundPixels, 1);
      if (sprite.roundPixels) {
        dx = dx | 0;
        dy = dy | 0;
      }
      var resolution = texture.baseTexture.resolution;
      var outerBlend = renderer._outerBlend;
      if (outerBlend) {
        context.save();
        context.beginPath();
        context.rect(dx * renderer.resolution, dy * renderer.resolution, destWidth * renderer.resolution, destHeight * renderer.resolution);
        context.clip();
      }
      if (sprite.tint !== 16777215) {
        if (sprite._cachedTint !== sprite.tint || sprite._tintedCanvas.tintId !== sprite._texture._updateID) {
          sprite._cachedTint = sprite.tint;
          sprite._tintedCanvas = canvasUtils.getTintedCanvas(sprite, sprite.tint);
        }
        context.drawImage(sprite._tintedCanvas, 0, 0, Math.floor(sourceWidth * resolution), Math.floor(sourceHeight * resolution), Math.floor(dx * renderer.resolution), Math.floor(dy * renderer.resolution), Math.floor(destWidth * renderer.resolution), Math.floor(destHeight * renderer.resolution));
      } else {
        context.drawImage(source, texture._frame.x * resolution, texture._frame.y * resolution, Math.floor(sourceWidth * resolution), Math.floor(sourceHeight * resolution), Math.floor(dx * renderer.resolution), Math.floor(dy * renderer.resolution), Math.floor(destWidth * renderer.resolution), Math.floor(destHeight * renderer.resolution));
      }
      if (outerBlend) {
        context.restore();
      }
      renderer.setBlendMode(BLEND_MODES.NORMAL);
    };
    CanvasSpriteRenderer2.prototype.destroy = function() {
      this.renderer = null;
    };
    CanvasSpriteRenderer2.extension = {
      name: "sprite",
      type: ExtensionType.CanvasRendererPlugin
    };
    return CanvasSpriteRenderer2;
  }()
);
Sprite.prototype._tintedCanvas = null;
Sprite.prototype._renderCanvas = function _renderCanvas7(renderer) {
  renderer.plugins.sprite.render(this);
};

// node_modules/@pixi/canvas-extract/dist/esm/canvas-extract.mjs
var TEMP_RECT = new Rectangle();
var CanvasExtract = (
  /** @class */
  function() {
    function CanvasExtract2(renderer) {
      this.renderer = renderer;
    }
    CanvasExtract2.prototype.image = function(target, format, quality) {
      var image = new Image();
      image.src = this.base64(target, format, quality);
      return image;
    };
    CanvasExtract2.prototype.base64 = function(target, format, quality) {
      return this.canvas(target).toDataURL(format, quality);
    };
    CanvasExtract2.prototype.canvas = function(target, frame) {
      var renderer = this.renderer;
      var context;
      var resolution;
      var renderTexture;
      if (target) {
        if (target instanceof RenderTexture) {
          renderTexture = target;
        } else {
          renderTexture = renderer.generateTexture(target);
        }
      }
      if (renderTexture) {
        context = renderTexture.baseTexture._canvasRenderTarget.context;
        resolution = renderTexture.baseTexture._canvasRenderTarget.resolution;
        frame = frame !== null && frame !== void 0 ? frame : renderTexture.frame;
      } else {
        context = renderer.rootContext;
        resolution = renderer.resolution;
        if (!frame) {
          frame = TEMP_RECT;
          frame.width = renderer.width;
          frame.height = renderer.height;
        }
      }
      var x = Math.round(frame.x * resolution);
      var y = Math.round(frame.y * resolution);
      var width = Math.round(frame.width * resolution);
      var height = Math.round(frame.height * resolution);
      var canvasBuffer = new CanvasRenderTarget(width, height, 1);
      var canvasData = context.getImageData(x, y, width, height);
      canvasBuffer.context.putImageData(canvasData, 0, 0);
      return canvasBuffer.canvas;
    };
    CanvasExtract2.prototype.pixels = function(target, frame) {
      var renderer = this.renderer;
      var context;
      var resolution;
      var renderTexture;
      if (target) {
        if (target instanceof RenderTexture) {
          renderTexture = target;
        } else {
          renderTexture = renderer.generateTexture(target);
        }
      }
      if (renderTexture) {
        context = renderTexture.baseTexture._canvasRenderTarget.context;
        resolution = renderTexture.baseTexture._canvasRenderTarget.resolution;
        frame = frame !== null && frame !== void 0 ? frame : renderTexture.frame;
      } else {
        context = renderer.rootContext;
        resolution = renderer.resolution;
        if (!frame) {
          frame = TEMP_RECT;
          frame.width = renderer.width;
          frame.height = renderer.height;
        }
      }
      var x = Math.round(frame.x * resolution);
      var y = Math.round(frame.y * resolution);
      var width = Math.round(frame.width * resolution);
      var height = Math.round(frame.height * resolution);
      return context.getImageData(x, y, width, height).data;
    };
    CanvasExtract2.prototype.destroy = function() {
      this.renderer = null;
    };
    CanvasExtract2.extension = {
      name: "extract",
      type: ExtensionType.CanvasRendererPlugin
    };
    return CanvasExtract2;
  }()
);

// node_modules/@pixi/canvas-prepare/dist/esm/canvas-prepare.mjs
var extendStatics2 = function(d, b) {
  extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics2(d, b);
};
function __extends2(d, b) {
  extendStatics2(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var CANVAS_START_SIZE = 16;
function uploadBaseTextures(prepare, item) {
  var tempPrepare = prepare;
  if (item instanceof BaseTexture) {
    var image = item.source;
    var imageWidth = image.width === 0 ? tempPrepare.canvas.width : Math.min(tempPrepare.canvas.width, image.width);
    var imageHeight = image.height === 0 ? tempPrepare.canvas.height : Math.min(tempPrepare.canvas.height, image.height);
    tempPrepare.ctx.drawImage(image, 0, 0, imageWidth, imageHeight, 0, 0, tempPrepare.canvas.width, tempPrepare.canvas.height);
    return true;
  }
  return false;
}
var CanvasPrepare = (
  /** @class */
  function(_super) {
    __extends2(CanvasPrepare2, _super);
    function CanvasPrepare2(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.uploadHookHelper = _this;
      _this.canvas = settings.ADAPTER.createCanvas(CANVAS_START_SIZE, CANVAS_START_SIZE);
      _this.ctx = _this.canvas.getContext("2d");
      _this.registerUploadHook(uploadBaseTextures);
      return _this;
    }
    CanvasPrepare2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.ctx = null;
      this.canvas = null;
    };
    CanvasPrepare2.extension = {
      name: "prepare",
      type: ExtensionType.CanvasRendererPlugin
    };
    return CanvasPrepare2;
  }(BasePrepare)
);

// node_modules/@pixi/canvas-sprite-tiling/dist/esm/canvas-sprite-tiling.mjs
var worldMatrix = new Matrix();
var patternMatrix = new Matrix();
var patternRect = [new Point(), new Point(), new Point(), new Point()];
TilingSprite.prototype._renderCanvas = function _renderCanvas8(renderer) {
  var texture = this._texture;
  if (!texture.baseTexture.valid) {
    return;
  }
  var context = renderer.context;
  var transform = this.worldTransform;
  var baseTexture = texture.baseTexture;
  var source = baseTexture.getDrawableSource();
  var baseTextureResolution = baseTexture.resolution;
  if (this._textureID !== this._texture._updateID || this._cachedTint !== this.tint) {
    this._textureID = this._texture._updateID;
    var tempCanvas = new CanvasRenderTarget(texture._frame.width, texture._frame.height, baseTextureResolution);
    if (this.tint !== 16777215) {
      this._tintedCanvas = canvasUtils.getTintedCanvas(this, this.tint);
      tempCanvas.context.drawImage(this._tintedCanvas, 0, 0);
    } else {
      tempCanvas.context.drawImage(source, -texture._frame.x * baseTextureResolution, -texture._frame.y * baseTextureResolution);
    }
    this._cachedTint = this.tint;
    this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, "repeat");
  }
  context.globalAlpha = this.worldAlpha;
  renderer.setBlendMode(this.blendMode);
  this.tileTransform.updateLocalTransform();
  var lt = this.tileTransform.localTransform;
  var W = this._width;
  var H = this._height;
  worldMatrix.identity();
  patternMatrix.copyFrom(lt);
  if (!this.uvRespectAnchor) {
    patternMatrix.translate(-this.anchor.x * W, -this.anchor.y * H);
  }
  patternMatrix.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);
  worldMatrix.prepend(patternMatrix);
  worldMatrix.prepend(transform);
  renderer.setContextTransform(worldMatrix);
  context.fillStyle = this._canvasPattern;
  var lx = this.anchor.x * -W;
  var ly = this.anchor.y * -H;
  patternRect[0].set(lx, ly);
  patternRect[1].set(lx + W, ly);
  patternRect[2].set(lx + W, ly + H);
  patternRect[3].set(lx, ly + H);
  for (var i = 0; i < 4; i++) {
    patternMatrix.applyInverse(patternRect[i], patternRect[i]);
  }
  context.beginPath();
  context.moveTo(patternRect[0].x, patternRect[0].y);
  for (var i = 1; i < 4; i++) {
    context.lineTo(patternRect[i].x, patternRect[i].y);
  }
  context.closePath();
  context.fill();
};

// node_modules/@pixi/canvas-particle-container/dist/esm/canvas-particle-container.mjs
ParticleContainer.prototype.renderCanvas = function renderCanvas(renderer) {
  if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
    return;
  }
  var context = renderer.context;
  var transform = this.worldTransform;
  var isRotated = true;
  var positionX = 0;
  var positionY = 0;
  var finalWidth = 0;
  var finalHeight = 0;
  renderer.setBlendMode(this.blendMode);
  context.globalAlpha = this.worldAlpha;
  this.displayObjectUpdateTransform();
  for (var i = 0; i < this.children.length; ++i) {
    var child = this.children[i];
    if (!child.visible) {
      continue;
    }
    if (!child._texture.valid) {
      continue;
    }
    var frame = child._texture.frame;
    context.globalAlpha = this.worldAlpha * child.alpha;
    if (child.rotation % (Math.PI * 2) === 0) {
      if (isRotated) {
        renderer.setContextTransform(transform, false, 1);
        isRotated = false;
      }
      positionX = child.anchor.x * (-frame.width * child.scale.x) + child.position.x + 0.5;
      positionY = child.anchor.y * (-frame.height * child.scale.y) + child.position.y + 0.5;
      finalWidth = frame.width * child.scale.x;
      finalHeight = frame.height * child.scale.y;
    } else {
      if (!isRotated) {
        isRotated = true;
      }
      child.displayObjectUpdateTransform();
      var childTransform = child.worldTransform;
      renderer.setContextTransform(childTransform, this.roundPixels, 1);
      positionX = child.anchor.x * -frame.width + 0.5;
      positionY = child.anchor.y * -frame.height + 0.5;
      finalWidth = frame.width;
      finalHeight = frame.height;
    }
    var resolution = child._texture.baseTexture.resolution;
    context.drawImage(child._texture.baseTexture.getDrawableSource(), frame.x * resolution, frame.y * resolution, frame.width * resolution, frame.height * resolution, positionX * renderer.resolution, positionY * renderer.resolution, finalWidth * renderer.resolution, finalHeight * renderer.resolution);
  }
};

// node_modules/@pixi/canvas-display/dist/esm/canvas-display.mjs
Container.prototype._renderCanvas = function _renderCanvas9(_renderer) {
};
Container.prototype.renderCanvas = function renderCanvas2(renderer) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  if (this._mask) {
    renderer.maskManager.pushMask(this._mask);
  }
  this._renderCanvas(renderer);
  for (var i = 0, j = this.children.length; i < j; ++i) {
    this.children[i].renderCanvas(renderer);
  }
  if (this._mask) {
    renderer.maskManager.popMask(renderer);
  }
};
DisplayObject.prototype.renderCanvas = function renderCanvas3(_renderer) {
};

// node_modules/@pixi/canvas-text/dist/esm/canvas-text.mjs
Text.prototype._renderCanvas = function _renderCanvas10(renderer) {
  if (this._autoResolution && this._resolution !== renderer.resolution) {
    this._resolution = renderer.resolution;
    this.dirty = true;
  }
  this.updateText(true);
  Sprite.prototype._renderCanvas.call(this, renderer);
};

// node_modules/pixi.js-legacy/dist/esm/pixi-legacy.mjs
extensions.add(CanvasExtract, CanvasGraphicsRenderer, CanvasMeshRenderer, CanvasPrepare, CanvasSpriteRenderer);
export {
  ALPHA_MODES,
  AbstractBatchRenderer,
  AbstractMultiResource,
  AbstractRenderer,
  AccessibilityManager,
  AnimatedSprite,
  AppLoaderPlugin,
  Application,
  ArrayResource,
  Attribute,
  BLEND_MODES,
  BUFFER_BITS,
  BUFFER_TYPE,
  BaseImageResource,
  BasePrepare,
  BaseRenderTexture,
  BaseTexture,
  BatchDrawCall,
  BatchGeometry,
  BatchPluginFactory,
  BatchRenderer,
  BatchShaderGenerator,
  BatchSystem,
  BatchTextureArray,
  BitmapFont,
  BitmapFontData,
  BitmapFontLoader,
  BitmapText,
  BlobResource,
  Bounds,
  BrowserAdapter,
  Buffer,
  BufferResource,
  CLEAR_MODES,
  COLOR_MASK_BITS,
  CanvasExtract,
  CanvasGraphicsRenderer,
  CanvasMeshRenderer,
  CanvasPrepare,
  CanvasRenderer,
  CanvasResource,
  CanvasSpriteRenderer,
  Circle,
  CompressedTextureLoader,
  CompressedTextureResource,
  Container,
  ContextSystem,
  CountLimiter,
  CubeResource,
  DDSLoader,
  DEG_TO_RAD,
  DRAW_MODES,
  DisplayObject,
  ENV,
  Ellipse,
  ExtensionType,
  Extract,
  FORMATS,
  FORMATS_TO_COMPONENTS,
  FillStyle,
  Filter,
  FilterState,
  FilterSystem,
  Framebuffer,
  FramebufferSystem,
  GC_MODES,
  GLFramebuffer,
  GLProgram,
  GLTexture,
  GRAPHICS_CURVES,
  Geometry,
  GeometrySystem,
  Graphics,
  GraphicsData,
  GraphicsGeometry,
  IGLUniformData,
  INSTALLED,
  INTERNAL_FORMATS,
  INTERNAL_FORMAT_TO_BYTES_PER_PIXEL,
  ImageBitmapResource,
  ImageResource,
  InteractionData,
  InteractionEvent,
  InteractionManager,
  InteractionTrackingData,
  KTXLoader,
  LINE_CAP,
  LINE_JOIN,
  LineStyle,
  Loader,
  LoaderResource,
  MASK_TYPES,
  MIPMAP_MODES,
  MSAA_QUALITY,
  MaskData,
  MaskSystem,
  Matrix,
  Mesh,
  MeshBatchUvs,
  MeshGeometry,
  MeshMaterial,
  NineSlicePlane,
  ObjectRenderer,
  ObservablePoint,
  PI_2,
  PRECISION,
  ParticleContainer,
  ParticleRenderer,
  PlaneGeometry,
  Point,
  Polygon,
  Prepare,
  Program,
  ProjectionSystem,
  Quad,
  QuadUv,
  RAD_TO_DEG,
  RENDERER_TYPE,
  Rectangle,
  RenderTexture,
  RenderTexturePool,
  RenderTextureSystem,
  Renderer,
  ResizePlugin,
  Resource,
  RopeGeometry,
  RoundedRectangle,
  Runner,
  SAMPLER_TYPES,
  SCALE_MODES,
  SHAPES,
  SVGResource,
  ScissorSystem,
  Shader,
  ShaderSystem,
  SimpleMesh,
  SimplePlane,
  SimpleRope,
  Sprite,
  SpriteMaskFilter,
  Spritesheet,
  SpritesheetLoader,
  State,
  StateSystem,
  StencilSystem,
  System,
  TARGETS,
  TEXT_GRADIENT,
  TYPES,
  TYPES_TO_BYTES_PER_COMPONENT,
  TYPES_TO_BYTES_PER_PIXEL,
  TemporaryDisplayObject,
  Text,
  TextFormat,
  TextMetrics,
  TextStyle,
  Texture,
  TextureGCSystem,
  TextureLoader,
  TextureMatrix,
  TextureSystem,
  TextureUvs,
  Ticker,
  TickerPlugin,
  TilingSprite,
  TilingSpriteRenderer,
  TimeLimiter,
  Transform,
  UPDATE_PRIORITY,
  UniformGroup,
  VERSION,
  VideoResource,
  ViewableBuffer,
  WRAP_MODES,
  XMLFormat,
  XMLStringFormat,
  accessibleTarget,
  autoDetectFormat,
  autoDetectRenderer,
  autoDetectResource,
  canvasUtils,
  checkMaxIfStatementsInShader,
  createUBOElements,
  defaultFilterVertex,
  defaultVertex$1 as defaultVertex,
  extensions,
  filters,
  generateProgram,
  generateUniformBufferSync,
  getTestContext,
  getUBOData,
  graphicsUtils,
  groupD8,
  interactiveTarget,
  isMobile,
  parseDDS,
  parseKTX,
  resources,
  settings,
  systems,
  uniformParsers,
  utils_exports as utils
};
/*! Bundled license information:

@pixi/canvas-renderer/dist/esm/canvas-renderer.mjs:
  (*!
   * @pixi/canvas-renderer - v6.5.10
   * Compiled Thu, 06 Jul 2023 15:25:11 UTC
   *
   * @pixi/canvas-renderer is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@pixi/canvas-mesh/dist/esm/canvas-mesh.mjs:
  (*!
   * @pixi/canvas-mesh - v6.5.10
   * Compiled Thu, 06 Jul 2023 15:25:11 UTC
   *
   * @pixi/canvas-mesh is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/canvas-graphics/dist/esm/canvas-graphics.mjs:
  (*!
   * @pixi/canvas-graphics - v6.5.10
   * Compiled Thu, 06 Jul 2023 15:25:11 UTC
   *
   * @pixi/canvas-graphics is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/canvas-sprite/dist/esm/canvas-sprite.mjs:
  (*!
   * @pixi/canvas-sprite - v6.5.10
   * Compiled Thu, 06 Jul 2023 15:25:11 UTC
   *
   * @pixi/canvas-sprite is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/canvas-extract/dist/esm/canvas-extract.mjs:
  (*!
   * @pixi/canvas-extract - v6.5.10
   * Compiled Thu, 06 Jul 2023 15:25:11 UTC
   *
   * @pixi/canvas-extract is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/canvas-prepare/dist/esm/canvas-prepare.mjs:
  (*!
   * @pixi/canvas-prepare - v6.5.10
   * Compiled Thu, 06 Jul 2023 15:25:11 UTC
   *
   * @pixi/canvas-prepare is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@pixi/canvas-sprite-tiling/dist/esm/canvas-sprite-tiling.mjs:
  (*!
   * @pixi/canvas-sprite-tiling - v6.5.10
   * Compiled Thu, 06 Jul 2023 15:25:11 UTC
   *
   * @pixi/canvas-sprite-tiling is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/canvas-particle-container/dist/esm/canvas-particle-container.mjs:
  (*!
   * @pixi/canvas-particle-container - v6.5.10
   * Compiled Thu, 06 Jul 2023 15:25:11 UTC
   *
   * @pixi/canvas-particle-container is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/canvas-display/dist/esm/canvas-display.mjs:
  (*!
   * @pixi/canvas-display - v6.5.10
   * Compiled Thu, 06 Jul 2023 15:25:11 UTC
   *
   * @pixi/canvas-display is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/canvas-text/dist/esm/canvas-text.mjs:
  (*!
   * @pixi/canvas-text - v6.5.10
   * Compiled Thu, 06 Jul 2023 15:25:11 UTC
   *
   * @pixi/canvas-text is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

pixi.js-legacy/dist/esm/pixi-legacy.mjs:
  (*!
   * pixi.js-legacy - v6.5.10
   * Compiled Thu, 06 Jul 2023 15:25:11 UTC
   *
   * pixi.js-legacy is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
*/
//# sourceMappingURL=pixi__js-legacy.js.map
