{
  "version": 3,
  "sources": ["../../node_modules/tslib/tslib.es6.js", "../../@pixi/canvas-renderer/src/utils/CanvasMaskManager.ts", "../../@pixi/canvas-renderer/src/utils/canUseNewCanvasBlendModes.ts", "../../@pixi/canvas-renderer/src/utils/mapCanvasBlendModesToPixi.ts", "../../@pixi/canvas-renderer/src/CanvasRenderer.ts", "../../@pixi/canvas-renderer/src/canvasUtils.ts", "../../@pixi/canvas-renderer/src/Renderer.ts", "../../@pixi/canvas-renderer/src/BaseTexture.ts", "../../@pixi/canvas-mesh/src/CanvasMeshRenderer.ts", "../../@pixi/canvas-mesh/src/settings.ts", "../../@pixi/canvas-mesh/src/MeshMaterial.ts", "../../@pixi/canvas-mesh/src/NineSlicePlane.ts", "../../@pixi/canvas-mesh/src/Mesh.ts", "../../@pixi/canvas-mesh/src/SimpleMesh.ts", "../../@pixi/canvas-mesh/src/SimpleRope.ts", "../../@pixi/canvas-graphics/src/utils/PolygonUtils.ts", "../../@pixi/canvas-graphics/src/CanvasGraphicsRenderer.ts", "../../@pixi/canvas-graphics/src/Graphics.ts", "../../@pixi/canvas-sprite/src/CanvasSpriteRenderer.ts", "../../@pixi/canvas-sprite/src/Sprite.ts", "../../@pixi/canvas-extract/src/CanvasExtract.ts", "../../node_modules/tslib/tslib.es6.js", "../../@pixi/canvas-prepare/src/CanvasPrepare.ts", "../../@pixi/canvas-sprite-tiling/src/TilingSprite.ts", "../../@pixi/canvas-particle-container/src/ParticleContainer.ts", "../../@pixi/canvas-display/src/Container.ts", "../../@pixi/canvas-display/src/DisplayObject.ts", "../../@pixi/canvas-text/src/Text.ts", "../../pixi.js-legacy/src/index.ts"],
  "sourcesContent": ["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n", "import type { Polygon } from '@pixi/math';\nimport { SHAPES } from '@pixi/math';\n\nimport type { CanvasRenderer } from '../CanvasRenderer';\nimport type { Graphics } from '@pixi/graphics';\nimport type { MaskData } from '@pixi/core';\nimport type { Container } from '@pixi/display';\n\n/**\n * A set of functions used to handle masking.\n *\n * Sprite masking is not supported on the CanvasRenderer.\n * @class\n * @memberof PIXI\n */\nexport class CanvasMaskManager\n{\n    /** A reference to the current renderer */\n    private renderer: CanvasRenderer;\n    private _foundShapes: Array<Graphics> = [];\n\n    /** @param renderer - A reference to the current renderer */\n    constructor(renderer: CanvasRenderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * This method adds it to the current stack of masks.\n     * @param maskData - the maskData that will be pushed\n     */\n    pushMask(maskData: MaskData | Graphics): void\n    {\n        const renderer = this.renderer;\n        const maskObject = ((maskData as MaskData).maskObject || maskData) as Container;\n\n        renderer.context.save();\n\n        // TODO support sprite alpha masks??\n        // lots of effort required. If demand is great enough..\n\n        const foundShapes = this._foundShapes;\n\n        this.recursiveFindShapes(maskObject, foundShapes);\n        if (foundShapes.length > 0)\n        {\n            const { context } = renderer;\n\n            context.beginPath();\n\n            for (let i = 0; i < foundShapes.length; i++)\n            {\n                const shape = foundShapes[i];\n                const transform = shape.transform.worldTransform;\n\n                this.renderer.setContextTransform(transform);\n\n                this.renderGraphicsShape(shape);\n            }\n\n            foundShapes.length = 0;\n            context.clip();\n        }\n    }\n\n    /**\n     * Renders all PIXI.Graphics shapes in a subtree.\n     * @param container - container to scan.\n     * @param out - where to put found shapes\n     */\n    recursiveFindShapes(container: Container, out: Array<Graphics>): void\n    {\n        if ((container as Graphics).geometry && (container as Graphics).geometry.graphicsData)\n        {\n            out.push(container as Graphics);\n        }\n\n        const { children } = container;\n\n        if (children)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                this.recursiveFindShapes(children[i] as Container, out);\n            }\n        }\n    }\n\n    /**\n     * Renders a PIXI.Graphics shape.\n     * @param graphics - The object to render.\n     */\n    renderGraphicsShape(graphics: Graphics): void\n    {\n        graphics.finishPoly();\n\n        const context = this.renderer.context;\n        const graphicsData = graphics.geometry.graphicsData;\n        const len = graphicsData.length;\n\n        if (len === 0)\n        {\n            return;\n        }\n\n        for (let i = 0; i < len; i++)\n        {\n            const data = graphicsData[i];\n            const shape = data.shape;\n\n            if (shape.type === SHAPES.POLY)\n            {\n                let points = shape.points;\n                const holes = data.holes;\n                let outerArea;\n                let innerArea;\n                let px;\n                let py;\n\n                context.moveTo(points[0], points[1]);\n\n                for (let j = 1; j < points.length / 2; j++)\n                {\n                    context.lineTo(points[j * 2], points[(j * 2) + 1]);\n                }\n                if (holes.length > 0)\n                {\n                    outerArea = 0;\n                    px = points[0];\n                    py = points[1];\n                    for (let j = 2; j + 2 < points.length; j += 2)\n                    {\n                        outerArea += ((points[j] - px) * (points[j + 3] - py))\n                            - ((points[j + 2] - px) * (points[j + 1] - py));\n                    }\n\n                    for (let k = 0; k < holes.length; k++)\n                    {\n                        points = (holes[k].shape as Polygon).points;\n\n                        if (!points)\n                        {\n                            continue;\n                        }\n\n                        innerArea = 0;\n                        px = points[0];\n                        py = points[1];\n                        for (let j = 2; j + 2 < points.length; j += 2)\n                        {\n                            innerArea += ((points[j] - px) * (points[j + 3] - py))\n                                - ((points[j + 2] - px) * (points[j + 1] - py));\n                        }\n\n                        if (innerArea * outerArea < 0)\n                        {\n                            context.moveTo(points[0], points[1]);\n\n                            for (let j = 2; j < points.length; j += 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n                        else\n                        {\n                            context.moveTo(points[points.length - 2], points[points.length - 1]);\n\n                            for (let j = points.length - 4; j >= 0; j -= 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n\n                        if ((holes[k].shape as Polygon).closeStroke)\n                        {\n                            context.closePath();\n                        }\n                    }\n                }\n                // if the first and last point are the same close the path - much neater :)\n                if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1])\n                {\n                    context.closePath();\n                }\n            }\n            else if (shape.type === SHAPES.RECT)\n            {\n                context.rect(shape.x, shape.y, shape.width, shape.height);\n                context.closePath();\n            }\n            else if (shape.type === SHAPES.CIRC)\n            {\n                // TODO - need to be Undefined!\n                context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);\n                context.closePath();\n            }\n            else if (shape.type === SHAPES.ELIP)\n            {\n                // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n\n                const w = shape.width * 2;\n                const h = shape.height * 2;\n\n                const x = shape.x - (w / 2);\n                const y = shape.y - (h / 2);\n\n                const kappa = 0.5522848;\n                const ox = (w / 2) * kappa; // control point offset horizontal\n                const oy = (h / 2) * kappa; // control point offset vertical\n                const xe = x + w; // x-end\n                const ye = y + h; // y-end\n                const xm = x + (w / 2); // x-middle\n                const ym = y + (h / 2); // y-middle\n\n                context.moveTo(x, ym);\n                context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n                context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n                context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n                context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n                context.closePath();\n            }\n            else if (shape.type === SHAPES.RREC)\n            {\n                const rx = shape.x;\n                const ry = shape.y;\n                const width = shape.width;\n                const height = shape.height;\n                let radius = shape.radius;\n\n                const maxRadius = Math.min(width, height) / 2;\n\n                radius = radius > maxRadius ? maxRadius : radius;\n\n                context.moveTo(rx, ry + radius);\n                context.lineTo(rx, ry + height - radius);\n                context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n                context.lineTo(rx + width - radius, ry + height);\n                context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n                context.lineTo(rx + width, ry + radius);\n                context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n                context.lineTo(rx + radius, ry);\n                context.quadraticCurveTo(rx, ry, rx, ry + radius);\n                context.closePath();\n            }\n        }\n    }\n\n    /**\n     * Restores the current drawing context to the state it was before the mask was applied.\n     * @param renderer - The renderer context to use.\n     */\n    popMask(renderer: CanvasRenderer): void\n    {\n        renderer.context.restore();\n        renderer.invalidateBlendMode();\n    }\n\n    /** Destroys this canvas mask manager. */\n    public destroy(): void\n    {\n        /* empty */\n    }\n}\n", "import { settings } from '@pixi/settings';\n\n/**\n * Creates a little colored canvas\n * @ignore\n * @param {string} color - The color to make the canvas\n * @returns {HTMLCanvasElement} a small canvas element\n */\nfunction createColoredCanvas(color: string): HTMLCanvasElement\n{\n    const canvas = settings.ADAPTER.createCanvas(6, 1);\n    const context = canvas.getContext('2d');\n\n    context.fillStyle = color;\n    context.fillRect(0, 0, 6, 1);\n\n    return canvas;\n}\n\n/**\n * Checks whether the Canvas BlendModes are supported by the current browser\n * @private\n * @returns {boolean} whether they are supported\n */\nexport function canUseNewCanvasBlendModes(): boolean\n{\n    if (typeof document === 'undefined')\n    {\n        return false;\n    }\n\n    const magenta = createColoredCanvas('#ff00ff');\n    const yellow = createColoredCanvas('#ffff00');\n\n    const canvas = settings.ADAPTER.createCanvas(6, 1);\n    const context = canvas.getContext('2d');\n\n    context.globalCompositeOperation = 'multiply';\n    context.drawImage(magenta, 0, 0);\n    context.drawImage(yellow, 2, 0);\n\n    const imageData = context.getImageData(2, 0, 1, 1);\n\n    if (!imageData)\n    {\n        return false;\n    }\n\n    const data = imageData.data;\n\n    return (data[0] === 255 && data[1] === 0 && data[2] === 0);\n}\n", "import { BLEND_MODES } from '@pixi/constants';\nimport { canUseNewCanvasBlendModes } from './canUseNewCanvasBlendModes';\n\n/**\n * Maps blend combinations to Canvas.\n * @memberof PIXI\n * @function mapCanvasBlendModesToPixi\n * @private\n * @param {string[]} [array=[]] - The array to output into.\n * @returns {string[]} Mapped modes.\n */\n// TODO after upgrading to typeScript 4.6, replace `string[]` with `GlobalCompositeOperation[]`\nexport function mapCanvasBlendModesToPixi(array: string[] = []): string[]\n{\n    if (canUseNewCanvasBlendModes())\n    {\n        array[BLEND_MODES.NORMAL] = 'source-over';\n        array[BLEND_MODES.ADD] = 'lighter'; // IS THIS OK???\n        array[BLEND_MODES.MULTIPLY] = 'multiply';\n        array[BLEND_MODES.SCREEN] = 'screen';\n        array[BLEND_MODES.OVERLAY] = 'overlay';\n        array[BLEND_MODES.DARKEN] = 'darken';\n        array[BLEND_MODES.LIGHTEN] = 'lighten';\n        array[BLEND_MODES.COLOR_DODGE] = 'color-dodge';\n        array[BLEND_MODES.COLOR_BURN] = 'color-burn';\n        array[BLEND_MODES.HARD_LIGHT] = 'hard-light';\n        array[BLEND_MODES.SOFT_LIGHT] = 'soft-light';\n        array[BLEND_MODES.DIFFERENCE] = 'difference';\n        array[BLEND_MODES.EXCLUSION] = 'exclusion';\n        array[BLEND_MODES.HUE] = 'hue';\n        array[BLEND_MODES.SATURATION] = 'saturation';\n        array[BLEND_MODES.COLOR] = 'color';\n        array[BLEND_MODES.LUMINOSITY] = 'luminosity';\n    }\n    else\n    {\n        // this means that the browser does not support the cool new blend modes in canvas 'cough' ie 'cough'\n        array[BLEND_MODES.NORMAL] = 'source-over';\n        array[BLEND_MODES.ADD] = 'lighter'; // IS THIS OK???\n        array[BLEND_MODES.MULTIPLY] = 'source-over';\n        array[BLEND_MODES.SCREEN] = 'source-over';\n        array[BLEND_MODES.OVERLAY] = 'source-over';\n        array[BLEND_MODES.DARKEN] = 'source-over';\n        array[BLEND_MODES.LIGHTEN] = 'source-over';\n        array[BLEND_MODES.COLOR_DODGE] = 'source-over';\n        array[BLEND_MODES.COLOR_BURN] = 'source-over';\n        array[BLEND_MODES.HARD_LIGHT] = 'source-over';\n        array[BLEND_MODES.SOFT_LIGHT] = 'source-over';\n        array[BLEND_MODES.DIFFERENCE] = 'source-over';\n        array[BLEND_MODES.EXCLUSION] = 'source-over';\n        array[BLEND_MODES.HUE] = 'source-over';\n        array[BLEND_MODES.SATURATION] = 'source-over';\n        array[BLEND_MODES.COLOR] = 'source-over';\n        array[BLEND_MODES.LUMINOSITY] = 'source-over';\n    }\n    // not-premultiplied, only for webgl\n    array[BLEND_MODES.NORMAL_NPM] = array[BLEND_MODES.NORMAL];\n    array[BLEND_MODES.ADD_NPM] = array[BLEND_MODES.ADD];\n    array[BLEND_MODES.SCREEN_NPM] = array[BLEND_MODES.SCREEN];\n\n    // composite operations\n    array[BLEND_MODES.SRC_IN] = 'source-in';\n    array[BLEND_MODES.SRC_OUT] = 'source-out';\n    array[BLEND_MODES.SRC_ATOP] = 'source-atop';\n    array[BLEND_MODES.DST_OVER] = 'destination-over';\n    array[BLEND_MODES.DST_IN] = 'destination-in';\n    array[BLEND_MODES.DST_OUT] = 'destination-out';\n    array[BLEND_MODES.DST_ATOP] = 'destination-atop';\n    array[BLEND_MODES.XOR] = 'xor';\n\n    // SUBTRACT from flash, does not exist in canvas\n    array[BLEND_MODES.SUBTRACT] = 'source-over';\n\n    return array;\n}\n", "import {\n    AbstractRenderer,\n    CanvasResource,\n    RenderTexture,\n    BaseRenderTexture,\n    extensions,\n    ExtensionType } from '@pixi/core';\nimport { CanvasRenderTarget, sayHello, rgb2hex, hex2string, deprecation } from '@pixi/utils';\nimport { CanvasMaskManager } from './utils/CanvasMaskManager';\nimport { mapCanvasBlendModesToPixi } from './utils/mapCanvasBlendModesToPixi';\nimport { RENDERER_TYPE, SCALE_MODES, BLEND_MODES } from '@pixi/constants';\nimport { settings } from '@pixi/settings';\nimport { Matrix } from '@pixi/math';\n\nimport type { DisplayObject } from '@pixi/display';\nimport type {\n    IRendererOptions,\n    IRendererPlugin,\n    IRendererPlugins,\n    IRendererRenderOptions\n} from '@pixi/core';\n\nconst tempMatrix = new Matrix();\n\nexport interface ICanvasRendererPluginConstructor\n{\n    new (renderer: CanvasRenderer, options?: any): IRendererPlugin;\n}\n\nexport interface ICanvasRendererPlugins\n{\n    [key: string]: any;\n}\n\n/*\n * Different browsers support different smoothing property names\n * this is the list of all platform props.\n */\ntype SmoothingEnabledProperties =\n    'imageSmoothingEnabled' |\n    'webkitImageSmoothingEnabled' |\n    'mozImageSmoothingEnabled' |\n    'oImageSmoothingEnabled' |\n    'msImageSmoothingEnabled';\n\n/**\n * Rendering context for all browsers. This includes platform-specific\n * properties that are not included in the spec for CanvasRenderingContext2D\n * @private\n */\nexport interface CrossPlatformCanvasRenderingContext2D extends CanvasRenderingContext2D\n{\n    webkitImageSmoothingEnabled: boolean;\n    mozImageSmoothingEnabled: boolean;\n    oImageSmoothingEnabled: boolean;\n    msImageSmoothingEnabled: boolean;\n}\n\n/**\n * The CanvasRenderer draws the scene and all its content onto a 2d canvas.\n *\n * This renderer should be used for browsers that do not support WebGL.\n * Don't forget to add the CanvasRenderer.view to your DOM or you will not see anything!\n * @class\n * @memberof PIXI\n * @extends PIXI.AbstractRenderer\n */\nexport class CanvasRenderer extends AbstractRenderer\n{\n    /**\n     * Fired after rendering finishes.\n     * @event PIXI.CanvasRenderer#postrender\n     */\n    /**\n     * Fired before rendering starts.\n     * @event PIXI.CanvasRenderer#prerender\n     */\n\n    /** The root canvas 2d context that everything is drawn with. */\n    public readonly rootContext: CrossPlatformCanvasRenderingContext2D;\n    /** The currently active canvas 2d context (could change with renderTextures) */\n    public context: CrossPlatformCanvasRenderingContext2D;\n    /** Boolean flag controlling canvas refresh. */\n    public refresh = true;\n    /**\n     * Instance of a CanvasMaskManager, handles masking when using the canvas renderer.\n     * @member {PIXI.CanvasMaskManager}\n     */\n    public maskManager: CanvasMaskManager = new CanvasMaskManager(this);\n    /** The canvas property used to set the canvas smoothing property. */\n    public smoothProperty: SmoothingEnabledProperties = 'imageSmoothingEnabled';\n    /** Tracks the blend modes useful for this renderer. */\n    public readonly blendModes: string[] = mapCanvasBlendModesToPixi();\n    public renderingToScreen = false;\n\n    private _activeBlendMode: BLEND_MODES = null;\n    /** Projection transform, passed in render() stored here */\n    private _projTransform: Matrix = null;\n\n    /** @private */\n    _outerBlend = false;\n\n    /**\n     * @param {PIXI.IRendererOptions} [options] - The optional renderer parameters.\n     * @param {boolean} [options.autoDensity=false] -\n     *  Whether the CSS dimensions of the renderer's view should be resized automatically.\n     * @param {number} [options.backgroundAlpha=1] -\n     *  Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n     * @param {number} [options.backgroundColor=0x000000] -\n     *  The background color used to clear the canvas. It accepts hex numbers (e.g. `0xff0000`).\n     * @param {boolean} [options.clearBeforeRender=true] - Whether to clear the canvas before new render passes.\n     * @param {number} [options.height=600] - The height of the renderer's view.\n     * @param {number} [options.resolution=PIXI.settings.RESOLUTION] -\n     *  The resolution / device pixel ratio of the renderer.\n     * @param {boolean} [options.transparent] -\n     *  **Deprecated since 6.0.0, Use `backgroundAlpha` instead.** \\\n     *  `true` sets `backgroundAlpha` to `0`, `false` sets `backgroundAlpha` to `1`.\n     * @param {boolean} [options.useContextAlpha=true] -\n     *  Pass-through value for canvas' context attribute `alpha`. This option is for cases where the\n     *  canvas needs to be opaque, possibly for performance reasons on some older devices.\n     *  If you want to set transparency, please use `backgroundAlpha`.\n     * @param {HTMLCanvasElement} [options.view=null] -\n     *  The canvas to use as the view. If omitted, a new canvas will be created.\n     * @param {number} [options.width=800] - The width of the renderer's view.\n     */\n    constructor(options?: IRendererOptions)\n    {\n        super(RENDERER_TYPE.CANVAS, options);\n\n        this.rootContext = this.view.getContext('2d', { alpha: this.useContextAlpha }) as\n            CrossPlatformCanvasRenderingContext2D;\n\n        this.context = this.rootContext;\n\n        if (!this.rootContext.imageSmoothingEnabled)\n        {\n            const rc = this.rootContext;\n\n            if (rc.webkitImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'webkitImageSmoothingEnabled';\n            }\n            else if (rc.mozImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'mozImageSmoothingEnabled';\n            }\n            else if (rc.oImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'oImageSmoothingEnabled';\n            }\n            else if (rc.msImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'msImageSmoothingEnabled';\n            }\n        }\n\n        this.initPlugins(CanvasRenderer.__plugins);\n\n        sayHello('Canvas');\n\n        this.resize(this.options.width, this.options.height);\n    }\n\n    /** Adds a new system to the renderer. It does nothing in the CanvasRenderer. */\n    addSystem(): this\n    {\n        return this;\n    }\n\n    /**\n     * Renders the object to its WebGL view.\n     * @param displayObject - The object to be rendered.\n     * @param options - Object to use for render options.\n     * @param {PIXI.RenderTexture} [options.renderTexture] - The render texture to render to.\n     * @param {boolean} [options.clear=true] - Should the canvas be cleared before the new render.\n     * @param {PIXI.Matrix} [options.transform] - A transform to apply to the render texture before rendering.\n     * @param {boolean} [options.skipUpdateTransform=false] - Should we skip the update transform pass?\n     */\n    render(displayObject: DisplayObject, options?: IRendererRenderOptions): void;\n\n    /**\n     * Please use the `option` render arguments instead.\n     * @deprecated Since 6.0.0\n     * @param displayObject - The object to be rendered.\n     * @param renderTexture - The render texture to render to.\n     * @param clear - Should the canvas be cleared before the new render.\n     * @param transform - A transform to apply to the render texture before rendering.\n     * @param skipUpdateTransform - Should we skip the update transform pass?\n     */\n    render(displayObject: DisplayObject, renderTexture?: RenderTexture | BaseRenderTexture,\n        clear?: boolean, transform?: Matrix, skipUpdateTransform?: boolean): void;\n\n    /** @ignore */\n    public render(displayObject: DisplayObject, options?: IRendererRenderOptions | RenderTexture | BaseRenderTexture): void\n    {\n        if (!this.view)\n        {\n            return;\n        }\n\n        let renderTexture: BaseRenderTexture | RenderTexture;\n        let clear: boolean;\n        let transform: Matrix;\n        let skipUpdateTransform: boolean;\n\n        if (options)\n        {\n            if (options instanceof RenderTexture || options instanceof BaseRenderTexture)\n            {\n                // #if _DEBUG\n                deprecation('6.0.0', 'CanvasRenderer#render arguments changed, use options instead.');\n                // #endif\n\n                /* eslint-disable prefer-rest-params */\n                renderTexture = options;\n                clear = arguments[2];\n                transform = arguments[3];\n                skipUpdateTransform = arguments[4];\n                /* eslint-enable prefer-rest-params */\n            }\n            else\n            {\n                renderTexture = options.renderTexture;\n                clear = options.clear;\n                transform = options.transform;\n                skipUpdateTransform = options.skipUpdateTransform;\n            }\n        }\n\n        // can be handy to know!\n        this.renderingToScreen = !renderTexture;\n\n        this.emit('prerender');\n\n        const rootResolution = this.resolution;\n\n        if (renderTexture)\n        {\n            renderTexture = renderTexture.castToBaseTexture() as BaseRenderTexture;\n\n            if (!renderTexture._canvasRenderTarget)\n            {\n                renderTexture._canvasRenderTarget = new CanvasRenderTarget(\n                    renderTexture.width,\n                    renderTexture.height,\n                    renderTexture.resolution\n                );\n                renderTexture.resource = new CanvasResource(renderTexture._canvasRenderTarget.canvas);\n                renderTexture.valid = true;\n            }\n\n            this.context = renderTexture._canvasRenderTarget.context as CrossPlatformCanvasRenderingContext2D;\n            this.resolution = renderTexture._canvasRenderTarget.resolution;\n        }\n        else\n        {\n            this.context = this.rootContext;\n        }\n\n        const context = this.context;\n\n        this._projTransform = transform || null;\n\n        if (!renderTexture)\n        {\n            this._lastObjectRendered = displayObject;\n        }\n\n        if (!skipUpdateTransform)\n        {\n            // update the scene graph\n            const cacheParent = displayObject.enableTempParent();\n\n            displayObject.updateTransform();\n            displayObject.disableTempParent(cacheParent);\n        }\n\n        context.save();\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.globalAlpha = 1;\n        this._activeBlendMode = BLEND_MODES.NORMAL;\n        this._outerBlend = false;\n        context.globalCompositeOperation = this.blendModes[BLEND_MODES.NORMAL];\n\n        if (clear !== undefined ? clear : this.clearBeforeRender)\n        {\n            if (this.renderingToScreen)\n            {\n                context.clearRect(0, 0, this.width, this.height);\n\n                if (this.backgroundAlpha > 0)\n                {\n                    context.globalAlpha = this.useContextAlpha ? this.backgroundAlpha : 1;\n                    context.fillStyle = this._backgroundColorString;\n                    context.fillRect(0, 0, this.width, this.height);\n                    context.globalAlpha = 1;\n                }\n            }\n            else\n            {\n                renderTexture = (renderTexture as BaseRenderTexture);\n                renderTexture._canvasRenderTarget.clear();\n\n                const clearColor = renderTexture.clearColor;\n\n                if (clearColor[3] > 0)\n                {\n                    context.globalAlpha = this.useContextAlpha ? clearColor[3] : 1;\n                    context.fillStyle = hex2string(rgb2hex(clearColor));\n                    context.fillRect(0, 0, renderTexture.realWidth, renderTexture.realHeight);\n                    context.globalAlpha = 1;\n                }\n            }\n        }\n\n        // TODO RENDER TARGET STUFF HERE..\n        const tempContext = this.context;\n\n        this.context = context;\n        displayObject.renderCanvas(this);\n        this.context = tempContext;\n\n        context.restore();\n\n        this.resolution = rootResolution;\n        this._projTransform = null;\n\n        this.emit('postrender');\n    }\n\n    /**\n     * Sets matrix of context.\n     * called only from render() methods\n     * takes care about resolution\n     * @param transform - world matrix of current element\n     * @param roundPixels - whether to round (tx,ty) coords\n     * @param localResolution - If specified, used instead of `renderer.resolution` for local scaling\n     */\n    setContextTransform(transform: Matrix, roundPixels?: boolean, localResolution?: number): void\n    {\n        let mat = transform;\n        const proj = this._projTransform;\n        const resolution = this.resolution;\n\n        localResolution = localResolution || resolution;\n\n        if (proj)\n        {\n            mat = tempMatrix;\n            mat.copyFrom(transform);\n            mat.prepend(proj);\n        }\n\n        if (roundPixels)\n        {\n            this.context.setTransform(\n                mat.a * localResolution,\n                mat.b * localResolution,\n                mat.c * localResolution,\n                mat.d * localResolution,\n                (mat.tx * resolution) | 0,\n                (mat.ty * resolution) | 0\n            );\n        }\n        else\n        {\n            this.context.setTransform(\n                mat.a * localResolution,\n                mat.b * localResolution,\n                mat.c * localResolution,\n                mat.d * localResolution,\n                mat.tx * resolution,\n                mat.ty * resolution\n            );\n        }\n    }\n\n    /**\n     * Clear the canvas of renderer.\n     * @param {string} [clearColor] - Clear the canvas with this color, except the canvas is transparent.\n     * @param {number} [alpha] - Alpha to apply to the background fill color.\n     */\n    public clear(clearColor: string = this._backgroundColorString, alpha: number = this.backgroundAlpha): void\n    {\n        const { context } = this;\n\n        context.clearRect(0, 0, this.width, this.height);\n\n        if (clearColor)\n        {\n            context.globalAlpha = this.useContextAlpha ? alpha : 1;\n            context.fillStyle = clearColor;\n            context.fillRect(0, 0, this.width, this.height);\n            context.globalAlpha = 1;\n        }\n    }\n\n    /**\n     * Sets the blend mode of the renderer.\n     * @param {number} blendMode - See {@link PIXI.BLEND_MODES} for valid values.\n     * @param {boolean} [readyForOuterBlend=false] - Some blendModes are dangerous, they affect outer space of sprite.\n     * Pass `true` only if you are ready to use them.\n     */\n    setBlendMode(blendMode: BLEND_MODES, readyForOuterBlend?: boolean): void\n    {\n        const outerBlend = blendMode === BLEND_MODES.SRC_IN\n            || blendMode === BLEND_MODES.SRC_OUT\n            || blendMode === BLEND_MODES.DST_IN\n            || blendMode === BLEND_MODES.DST_ATOP;\n\n        if (!readyForOuterBlend && outerBlend)\n        {\n            blendMode = BLEND_MODES.NORMAL;\n        }\n\n        if (this._activeBlendMode === blendMode)\n        {\n            return;\n        }\n\n        this._activeBlendMode = blendMode;\n        this._outerBlend = outerBlend;\n        this.context.globalCompositeOperation = this.blendModes[blendMode];\n    }\n\n    /**\n     * Removes everything from the renderer and optionally removes the Canvas DOM element.\n     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.\n     */\n    public destroy(removeView?: boolean): void\n    {\n        // call the base destroy\n        super.destroy(removeView);\n\n        this.context = null;\n\n        this.refresh = true;\n\n        this.maskManager.destroy();\n        this.maskManager = null;\n\n        this.smoothProperty = null;\n    }\n\n    /**\n     * Resizes the canvas view to the specified width and height.\n     * @extends PIXI.AbstractRenderer#resize\n     * @param desiredScreenWidth - the desired width of the screen\n     * @param desiredScreenHeight - the desired height of the screen\n     */\n    public resize(desiredScreenWidth: number, desiredScreenHeight: number): void\n    {\n        super.resize(desiredScreenWidth, desiredScreenHeight);\n\n        // reset the scale mode.. oddly this seems to be reset when the canvas is resized.\n        // surely a browser bug?? Let PixiJS fix that for you..\n        if (this.smoothProperty)\n        {\n            this.rootContext[this.smoothProperty] = (settings.SCALE_MODE === SCALE_MODES.LINEAR);\n        }\n    }\n\n    /** Checks if blend mode has changed. */\n    invalidateBlendMode(): void\n    {\n        this._activeBlendMode = this.blendModes.indexOf(this.context.globalCompositeOperation);\n    }\n\n    static __plugins: IRendererPlugins = {};\n\n    /**\n     * Collection of installed plugins. These are included by default in PIXI, but can be excluded\n     * by creating a custom build. Consult the README for more information about creating custom\n     * builds and excluding plugins.\n     * @member {object} plugins\n     * @readonly\n     * @property {PIXI.AccessibilityManager} accessibility Support tabbing interactive elements.\n     * @property {PIXI.CanvasExtract} extract Extract image data from renderer.\n     * @property {PIXI.InteractionManager} interaction Handles mouse, touch and pointer events.\n     * @property {PIXI.CanvasPrepare} prepare Pre-render display objects.\n     */\n\n    /**\n     * Use the {@link PIXI.extensions.add} API to register plugins.\n     * @deprecated since 6.5.0\n     * @param pluginName - The name of the plugin.\n     * @param ctor - The constructor function or class for the plugin.\n     */\n    static registerPlugin(pluginName: string, ctor: ICanvasRendererPluginConstructor): void\n    {\n        // #if _DEBUG\n        deprecation('6.5.0', 'CanvasRenderer.registerPlugin() has been deprecated, please use extensions.add() instead.');\n        // #endif\n        extensions.add({\n            name: pluginName,\n            type: ExtensionType.CanvasRendererPlugin,\n            ref: ctor,\n        });\n    }\n}\n\nextensions.handleByMap(ExtensionType.CanvasRendererPlugin, CanvasRenderer.__plugins);\n", "import { hex2rgb, rgb2hex } from '@pixi/utils';\nimport { settings } from '@pixi/settings';\nimport { canUseNewCanvasBlendModes } from './utils/canUseNewCanvasBlendModes';\n\nimport type { Texture } from '@pixi/core';\n\n/**\n * Utility methods for Sprite/Texture tinting.\n *\n * Tinting with the CanvasRenderer involves creating a new canvas to use as a texture,\n * so be aware of the performance implications.\n * @namespace PIXI.canvasUtils\n * @memberof PIXI\n */\nexport const canvasUtils = {\n    canvas: null as HTMLCanvasElement,\n\n    /**\n     * Basically this method just needs a sprite and a color and tints the sprite with the given color.\n     * @memberof PIXI.canvasUtils\n     * @param {PIXI.Sprite} sprite - the sprite to tint\n     * @param sprite.texture\n     * @param {number} color - the color to use to tint the sprite with\n     * @returns {HTMLCanvasElement} The tinted canvas\n     */\n    getTintedCanvas: (sprite: { texture: Texture }, color: number): HTMLCanvasElement | HTMLImageElement =>\n    {\n        const texture = sprite.texture;\n\n        color = canvasUtils.roundColor(color);\n\n        const stringColor = `#${(`00000${(color | 0).toString(16)}`).slice(-6)}`;\n\n        texture.tintCache = texture.tintCache || {};\n\n        const cachedCanvas = texture.tintCache[stringColor];\n\n        let canvas: HTMLCanvasElement;\n\n        if (cachedCanvas)\n        {\n            if (cachedCanvas.tintId === texture._updateID)\n            {\n                return texture.tintCache[stringColor];\n            }\n\n            canvas = texture.tintCache[stringColor] as HTMLCanvasElement;\n        }\n        else\n        {\n            canvas = settings.ADAPTER.createCanvas();\n        }\n\n        canvasUtils.tintMethod(texture, color, canvas);\n\n        canvas.tintId = texture._updateID;\n\n        if (canvasUtils.convertTintToImage)\n        {\n            // is this better?\n            const tintImage = new Image();\n\n            tintImage.src = (canvas as HTMLCanvasElement).toDataURL();\n\n            texture.tintCache[stringColor] = tintImage;\n        }\n        else\n        {\n            texture.tintCache[stringColor] = canvas;\n        }\n\n        return canvas;\n    },\n\n    /**\n     * Basically this method just needs a sprite and a color and tints the sprite with the given color.\n     * @memberof PIXI.canvasUtils\n     * @param {PIXI.Texture} texture - the sprite to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @returns {HTMLCanvasElement} The tinted canvas\n     */\n    getTintedPattern: (texture: Texture, color: number): CanvasPattern =>\n    {\n        color = canvasUtils.roundColor(color);\n\n        const stringColor = `#${(`00000${(color | 0).toString(16)}`).slice(-6)}`;\n\n        texture.patternCache = texture.patternCache || {};\n\n        let pattern = texture.patternCache[stringColor];\n\n        if (pattern && pattern.tintId === texture._updateID)\n        {\n            return pattern;\n        }\n        if (!canvasUtils.canvas)\n        {\n            canvasUtils.canvas = settings.ADAPTER.createCanvas();\n        }\n        canvasUtils.tintMethod(texture, color, canvasUtils.canvas);\n        pattern = canvasUtils.canvas.getContext('2d').createPattern(canvasUtils.canvas, 'repeat');\n        pattern.tintId = texture._updateID;\n        texture.patternCache[stringColor] = pattern;\n\n        return pattern;\n    },\n\n    /**\n     * Tint a texture using the 'multiply' operation.\n     * @memberof PIXI.canvasUtils\n     * @param {PIXI.Texture} texture - the texture to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @param {HTMLCanvasElement} canvas - the current canvas\n     */\n    tintWithMultiply: (texture: Texture, color: number, canvas: HTMLCanvasElement): void =>\n    {\n        const context = canvas.getContext('2d');\n        const crop = texture._frame.clone();\n        const resolution = texture.baseTexture.resolution;\n\n        crop.x *= resolution;\n        crop.y *= resolution;\n        crop.width *= resolution;\n        crop.height *= resolution;\n\n        canvas.width = Math.ceil(crop.width);\n        canvas.height = Math.ceil(crop.height);\n\n        context.save();\n        context.fillStyle = `#${(`00000${(color | 0).toString(16)}`).slice(-6)}`;\n\n        context.fillRect(0, 0, crop.width, crop.height);\n\n        context.globalCompositeOperation = 'multiply';\n\n        const source = texture.baseTexture.getDrawableSource();\n\n        context.drawImage(\n            source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n\n        context.globalCompositeOperation = 'destination-atop';\n\n        context.drawImage(\n            source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n        context.restore();\n    },\n\n    /**\n     * Tint a texture using the 'overlay' operation.\n     * @memberof PIXI.canvasUtils\n     * @param {PIXI.Texture} texture - the texture to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @param {HTMLCanvasElement} canvas - the current canvas\n     */\n    tintWithOverlay: (texture: Texture, color: number, canvas: HTMLCanvasElement): void =>\n    {\n        const context = canvas.getContext('2d');\n        const crop = texture._frame.clone();\n        const resolution = texture.baseTexture.resolution;\n\n        crop.x *= resolution;\n        crop.y *= resolution;\n        crop.width *= resolution;\n        crop.height *= resolution;\n\n        canvas.width = Math.ceil(crop.width);\n        canvas.height = Math.ceil(crop.height);\n\n        context.save();\n        context.globalCompositeOperation = 'copy';\n        context.fillStyle = `#${(`00000${(color | 0).toString(16)}`).slice(-6)}`;\n        context.fillRect(0, 0, crop.width, crop.height);\n\n        context.globalCompositeOperation = 'destination-atop';\n        context.drawImage(\n            texture.baseTexture.getDrawableSource(),\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n\n        // context.globalCompositeOperation = 'copy';\n        context.restore();\n    },\n\n    /**\n     * Tint a texture pixel per pixel.\n     * @memberof PIXI.canvasUtils\n     * @param {PIXI.Texture} texture - the texture to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @param {HTMLCanvasElement} canvas - the current canvas\n     */\n    tintWithPerPixel: (texture: Texture, color: number, canvas: HTMLCanvasElement): void =>\n    {\n        const context = canvas.getContext('2d');\n        const crop = texture._frame.clone();\n        const resolution = texture.baseTexture.resolution;\n\n        crop.x *= resolution;\n        crop.y *= resolution;\n        crop.width *= resolution;\n        crop.height *= resolution;\n\n        canvas.width = Math.ceil(crop.width);\n        canvas.height = Math.ceil(crop.height);\n\n        context.save();\n        context.globalCompositeOperation = 'copy';\n        context.drawImage(\n            texture.baseTexture.getDrawableSource(),\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n        context.restore();\n\n        const rgbValues = hex2rgb(color);\n        const r = rgbValues[0];\n        const g = rgbValues[1];\n        const b = rgbValues[2];\n\n        const pixelData = context.getImageData(0, 0, crop.width, crop.height);\n\n        const pixels = pixelData.data;\n\n        for (let i = 0; i < pixels.length; i += 4)\n        {\n            pixels[i + 0] *= r;\n            pixels[i + 1] *= g;\n            pixels[i + 2] *= b;\n        }\n\n        context.putImageData(pixelData, 0, 0);\n    },\n\n    /**\n     * Rounds the specified color according to the canvasUtils.cacheStepsPerColorChannel.\n     * @memberof PIXI.canvasUtils\n     * @param {number} color - the color to round, should be a hex color\n     * @returns {number} The rounded color.\n     */\n    roundColor: (color: number): number =>\n    {\n        const step = canvasUtils.cacheStepsPerColorChannel;\n\n        const rgbValues = hex2rgb(color);\n\n        rgbValues[0] = Math.min(255, (rgbValues[0] / step) * step);\n        rgbValues[1] = Math.min(255, (rgbValues[1] / step) * step);\n        rgbValues[2] = Math.min(255, (rgbValues[2] / step) * step);\n\n        return rgb2hex(rgbValues);\n    },\n\n    /**\n     * Number of steps which will be used as a cap when rounding colors.\n     * @memberof PIXI.canvasUtils\n     * @type {number}\n     */\n    cacheStepsPerColorChannel: 8,\n\n    /**\n     * Tint cache boolean flag.\n     * @memberof PIXI.canvasUtils\n     * @type {boolean}\n     */\n    convertTintToImage: false,\n\n    /**\n     * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.\n     * @memberof PIXI.canvasUtils\n     * @type {boolean}\n     */\n    canUseMultiply: canUseNewCanvasBlendModes(),\n\n    /**\n     * The tinting method that will be used.\n     * @memberof PIXI.canvasUtils\n     * @type {Function}\n     */\n    tintMethod: null as (texture: Texture, color: number, canvas: HTMLCanvasElement) => void,\n};\n\ncanvasUtils.tintMethod = canvasUtils.canUseMultiply ? canvasUtils.tintWithMultiply : canvasUtils.tintWithPerPixel;\n", "import { Renderer } from '@pixi/core';\nimport { CanvasRenderer } from './CanvasRenderer';\n\nimport type { AbstractRenderer, IRendererOptionsAuto } from '@pixi/core';\n\n// Reference to Renderer.create static function\nconst parentCreate = Renderer.create;\n\n/**\n * Override the Renderer.create to fallback to use CanvasRenderer.\n * Also supports forceCanvas option with Application or autoDetectRenderer.\n * @param options\n * @private\n */\nRenderer.create = function create(options: IRendererOptionsAuto): AbstractRenderer\n{\n    const forceCanvas = options && options.forceCanvas;\n\n    if (!forceCanvas)\n    {\n        try\n        {\n            return parentCreate(options);\n        }\n        catch (err)\n        {\n            // swallow WebGL-unsupported error\n        }\n    }\n\n    return new CanvasRenderer(options);\n};\n", "import { BaseTexture, BaseRenderTexture, Texture } from '@pixi/core';\n\n/**\n * Get the drawable source, such as HTMLCanvasElement or HTMLImageElement suitable\n * for rendering with CanvasRenderer. Provided by **@pixi/canvas-renderer** package.\n * @method getDrawableSource\n * @memberof PIXI.BaseTexture#\n * @returns {PIXI.ICanvasImageSource} Source to render with CanvasRenderer\n */\nBaseTexture.prototype.getDrawableSource = function getDrawableSource(): CanvasImageSource\n{\n    const resource = this.resource as any;\n\n    return resource ? (resource.bitmap || resource.source) : null;\n};\n\n/**\n * A reference to the canvas render target (we only need one as this can be shared across renderers)\n * @protected\n * @member {PIXI.utils.CanvasRenderTarget} _canvasRenderTarget\n * @memberof PIXI.BaseRenderTexture#\n */\n\nBaseRenderTexture.prototype._canvasRenderTarget = null;\n\nTexture.prototype.patternCache = null;\n\nTexture.prototype.tintCache = null;\n", "import type { ExtensionMetadata } from '@pixi/core';\nimport { ExtensionType, Texture } from '@pixi/core';\nimport { DRAW_MODES } from '@pixi/constants';\nimport { canvasUtils } from '@pixi/canvas-renderer';\n\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\nimport type { Mesh } from '@pixi/mesh';\n\n/**\n * Renderer dedicated to meshes.\n * @class\n * @protected\n * @memberof PIXI\n */\nexport class CanvasMeshRenderer\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'mesh',\n        type: ExtensionType.CanvasRendererPlugin,\n    };\n\n    /** A reference to the current renderer */\n    public renderer: CanvasRenderer;\n\n    /** @param renderer - A reference to the current renderer */\n    constructor(renderer: CanvasRenderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * Renders the Mesh\n     * @param mesh - the Mesh to render\n     */\n    public render(mesh: Mesh): void\n    {\n        const renderer = this.renderer;\n        const transform = mesh.worldTransform;\n\n        renderer.context.globalAlpha = mesh.worldAlpha;\n        renderer.setBlendMode(mesh.blendMode);\n        renderer.setContextTransform(transform, mesh.roundPixels);\n\n        if (mesh.drawMode !== DRAW_MODES.TRIANGLES)\n        {\n            this._renderTriangleMesh(mesh);\n        }\n        else\n        {\n            this._renderTriangles(mesh);\n        }\n    }\n\n    /**\n     * Draws the object in Triangle Mesh mode\n     * @private\n     * @param mesh - the Mesh to render\n     */\n    private _renderTriangleMesh(mesh: Mesh): void\n    {\n        // draw triangles!!\n        const length = mesh.geometry.buffers[0].data.length;\n\n        for (let i = 0; i < length - 2; i++)\n        {\n            // draw some triangles!\n            const index = i * 2;\n\n            this._renderDrawTriangle(mesh, index, (index + 2), (index + 4));\n        }\n    }\n\n    /**\n     * Draws the object in triangle mode using canvas\n     * @private\n     * @param mesh - the current mesh\n     */\n    private _renderTriangles(mesh: Mesh): void\n    {\n        // draw triangles!!\n        const indices = mesh.geometry.getIndex().data;\n        const length = indices.length;\n\n        for (let i = 0; i < length; i += 3)\n        {\n            // draw some triangles!\n            const index0 = indices[i] * 2;\n            const index1 = indices[i + 1] * 2;\n            const index2 = indices[i + 2] * 2;\n\n            this._renderDrawTriangle(mesh, index0, index1, index2);\n        }\n    }\n\n    /**\n     * Draws one of the triangles that from the Mesh\n     * @private\n     * @param mesh - the current mesh\n     * @param index0 - the index of the first vertex\n     * @param index1 - the index of the second vertex\n     * @param index2 - the index of the third vertex\n     */\n    private _renderDrawTriangle(mesh: Mesh, index0: number, index1: number, index2: number): void\n    {\n        const context = this.renderer.context;\n        const vertices = mesh.geometry.buffers[0].data;\n        const { uvs, texture } = mesh;\n\n        if (!texture.valid)\n        {\n            return;\n        }\n        const isTinted = mesh.tint !== 0xFFFFFF;\n        const base = texture.baseTexture;\n        const textureWidth = base.width;\n        const textureHeight = base.height;\n\n        if (isTinted)\n        {\n            if (mesh._cachedTint !== mesh.tint)\n            {\n                mesh._cachedTint = mesh.tint;\n                mesh._cachedTexture = mesh._cachedTexture || new Texture(base);\n                mesh._tintedCanvas = canvasUtils.getTintedCanvas(\n                    { texture: mesh._cachedTexture },\n                    mesh.tint\n                ) as HTMLCanvasElement;\n            }\n        }\n\n        const textureSource = isTinted ? mesh._tintedCanvas : base.getDrawableSource();\n\n        const u0 = uvs[index0] * base.width;\n        const u1 = uvs[index1] * base.width;\n        const u2 = uvs[index2] * base.width;\n        const v0 = uvs[index0 + 1] * base.height;\n        const v1 = uvs[index1 + 1] * base.height;\n        const v2 = uvs[index2 + 1] * base.height;\n\n        let x0 = vertices[index0];\n        let x1 = vertices[index1];\n        let x2 = vertices[index2];\n        let y0 = vertices[index0 + 1];\n        let y1 = vertices[index1 + 1];\n        let y2 = vertices[index2 + 1];\n\n        const screenPadding = mesh.canvasPadding / this.renderer.resolution;\n\n        if (screenPadding > 0)\n        {\n            const { a, b, c, d } = mesh.worldTransform;\n\n            const centerX = (x0 + x1 + x2) / 3;\n            const centerY = (y0 + y1 + y2) / 3;\n\n            let normX = x0 - centerX;\n            let normY = y0 - centerY;\n\n            // Transform to screen space and calculate the distance\n            let screenX = (a * normX) + (c * normY);\n            let screenY = (b * normX) + (d * normY);\n            let screenDist = Math.sqrt((screenX * screenX) + (screenY * screenY));\n\n            // Factor by which to scale in order to add padding equal to screenPadding\n            let paddingFactor = 1 + (screenPadding / screenDist);\n\n            x0 = centerX + (normX * paddingFactor);\n            y0 = centerY + (normY * paddingFactor);\n\n            normX = x1 - centerX;\n            normY = y1 - centerY;\n\n            screenX = (a * normX) + (c * normY);\n            screenY = (b * normX) + (d * normY);\n            screenDist = Math.sqrt((screenX * screenX) + (screenY * screenY));\n\n            paddingFactor = 1 + (screenPadding / screenDist);\n\n            x1 = centerX + (normX * paddingFactor);\n            y1 = centerY + (normY * paddingFactor);\n\n            normX = x2 - centerX;\n            normY = y2 - centerY;\n\n            screenX = (a * normX) + (c * normY);\n            screenY = (b * normX) + (d * normY);\n            screenDist = Math.sqrt((screenX * screenX) + (screenY * screenY));\n\n            paddingFactor = 1 + (screenPadding / screenDist);\n\n            x2 = centerX + (normX * paddingFactor);\n            y2 = centerY + (normY * paddingFactor);\n        }\n\n        context.save();\n        context.beginPath();\n\n        context.moveTo(x0, y0);\n        context.lineTo(x1, y1);\n        context.lineTo(x2, y2);\n\n        context.closePath();\n\n        context.clip();\n\n        // Compute matrix transform\n        const delta = (u0 * v1) + (v0 * u2) + (u1 * v2) - (v1 * u2) - (v0 * u1) - (u0 * v2);\n        const deltaA = (x0 * v1) + (v0 * x2) + (x1 * v2) - (v1 * x2) - (v0 * x1) - (x0 * v2);\n        const deltaB = (u0 * x1) + (x0 * u2) + (u1 * x2) - (x1 * u2) - (x0 * u1) - (u0 * x2);\n        const deltaC = (u0 * v1 * x2) + (v0 * x1 * u2) + (x0 * u1 * v2) - (x0 * v1 * u2) - (v0 * u1 * x2) - (u0 * x1 * v2);\n        const deltaD = (y0 * v1) + (v0 * y2) + (y1 * v2) - (v1 * y2) - (v0 * y1) - (y0 * v2);\n        const deltaE = (u0 * y1) + (y0 * u2) + (u1 * y2) - (y1 * u2) - (y0 * u1) - (u0 * y2);\n        const deltaF = (u0 * v1 * y2) + (v0 * y1 * u2) + (y0 * u1 * v2) - (y0 * v1 * u2) - (v0 * u1 * y2) - (u0 * y1 * v2);\n\n        context.transform(\n            deltaA / delta,\n            deltaD / delta,\n            deltaB / delta,\n            deltaE / delta,\n            deltaC / delta,\n            deltaF / delta\n        );\n\n        context.drawImage(\n            textureSource,\n            0,\n            0,\n            textureWidth * base.resolution,\n            textureHeight * base.resolution,\n            0,\n            0,\n            textureWidth,\n            textureHeight\n        );\n\n        context.restore();\n        this.renderer.invalidateBlendMode();\n    }\n\n    /**\n     * Renders a flat Mesh\n     * @private\n     * @param mesh - The Mesh to render\n     */\n    renderMeshFlat(mesh: Mesh): void\n    {\n        const context = this.renderer.context;\n        const vertices = mesh.geometry.getBuffer('aVertexPosition').data;\n        const length = vertices.length / 2;\n\n        // this.count++;\n\n        context.beginPath();\n\n        for (let i = 1; i < length - 2; ++i)\n        {\n            // draw some triangles!\n            const index = i * 2;\n\n            const x0 = vertices[index];\n            const y0 = vertices[index + 1];\n\n            const x1 = vertices[index + 2];\n            const y1 = vertices[index + 3];\n\n            const x2 = vertices[index + 4];\n            const y2 = vertices[index + 5];\n\n            context.moveTo(x0, y0);\n            context.lineTo(x1, y1);\n            context.lineTo(x2, y2);\n        }\n\n        context.fillStyle = '#FF0000';\n        context.fill();\n        context.closePath();\n    }\n\n    /** destroy the renderer */\n    public destroy(): void\n    {\n        this.renderer = null;\n    }\n}\n", "import { settings } from '@pixi/settings';\n\n/**\n * Default `canvasPadding` for canvas-based Mesh rendering.\n * @see PIXI.Mesh2d#canvasPadding\n * @static\n * @memberof PIXI.settings\n * @member {number}\n * @default 0\n */\nsettings.MESH_CANVAS_PADDING = 0;\n\nexport { settings };\n", "import { MeshMaterial } from '@pixi/mesh';\n\nimport type { Mesh } from '@pixi/mesh';\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\n\n/**\n * Renders the mesh using the Canvas renderer\n * @protected\n * @method render\n * @memberof PIXI.MeshMaterial#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n * @param {PIXI.Mesh} mesh - Mesh to render.\n */\nMeshMaterial.prototype._renderCanvas = function _renderCanvas(renderer: CanvasRenderer, mesh: Mesh): void\n{\n    renderer.plugins.mesh.render(mesh);\n};\n", "import { canvasUtils } from '@pixi/canvas-renderer';\nimport { NineSlicePlane } from '@pixi/mesh-extras';\n\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\n\n/**\n * Cached tint value so we can tell when the tint is changed.\n * @memberof PIXI.NineSlicePlane#\n * @member {number} _cachedTint\n * @protected\n */\nNineSlicePlane.prototype._cachedTint = 0xFFFFFF;\n\n/**\n * Cached tinted texture.\n * @memberof PIXI.NineSlicePlane#\n * @member {HTMLCanvasElement} _tintedCanvas\n * @protected\n */\nNineSlicePlane.prototype._tintedCanvas = null;\n\n/**\n * Temporary storage for canvas source coords\n * @memberof PIXI.NineSlicePlane#\n * @member {number[]} _canvasUvs\n * @private\n */\nNineSlicePlane.prototype._canvasUvs = null;\n\n/**\n * Renders the object using the Canvas renderer\n * @private\n * @method _renderCanvas\n * @memberof PIXI.NineSlicePlane#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer to render with.\n */\nNineSlicePlane.prototype._renderCanvas = function _renderCanvas(renderer: CanvasRenderer): void\n{\n    const context = renderer.context;\n    const transform = this.worldTransform;\n    const isTinted = this.tint !== 0xFFFFFF;\n    const texture = this.texture;\n\n    if (!texture.valid)\n    {\n        return;\n    }\n\n    // Work out tinting\n    if (isTinted)\n    {\n        if (this._cachedTint !== this.tint)\n        {\n            // Tint has changed, need to update the tinted texture and use that instead\n\n            this._cachedTint = this.tint;\n\n            this._tintedCanvas = canvasUtils.getTintedCanvas(this, this.tint) as HTMLCanvasElement;\n        }\n    }\n\n    const textureSource = !isTinted ? texture.baseTexture.getDrawableSource() : this._tintedCanvas;\n\n    if (!this._canvasUvs)\n    {\n        this._canvasUvs = [0, 0, 0, 0, 0, 0, 0, 0];\n    }\n\n    const vertices = this.vertices;\n    const uvs = this._canvasUvs;\n    const u0 = isTinted ? 0 : texture.frame.x;\n    const v0 = isTinted ? 0 : texture.frame.y;\n    const u1 = u0 + texture.frame.width;\n    const v1 = v0 + texture.frame.height;\n\n    uvs[0] = u0;\n    uvs[1] = u0 + this._leftWidth;\n    uvs[2] = u1 - this._rightWidth;\n    uvs[3] = u1;\n    uvs[4] = v0;\n    uvs[5] = v0 + this._topHeight;\n    uvs[6] = v1 - this._bottomHeight;\n    uvs[7] = v1;\n\n    for (let i = 0; i < 8; i++)\n    {\n        uvs[i] *= texture.baseTexture.resolution;\n    }\n\n    context.globalAlpha = this.worldAlpha;\n    renderer.setBlendMode(this.blendMode);\n    renderer.setContextTransform(transform, this.roundPixels);\n\n    for (let row = 0; row < 3; row++)\n    {\n        for (let col = 0; col < 3; col++)\n        {\n            const ind = (col * 2) + (row * 8);\n            const sw = Math.max(1, uvs[col + 1] - uvs[col]);\n            const sh = Math.max(1, uvs[row + 5] - uvs[row + 4]);\n            const dw = Math.max(1, vertices[ind + 10] - vertices[ind]);\n            const dh = Math.max(1, vertices[ind + 11] - vertices[ind + 1]);\n\n            context.drawImage(textureSource, uvs[col], uvs[row + 4], sw, sh,\n                vertices[ind], vertices[ind + 1], dw, dh);\n        }\n    }\n};\n", "import { Mesh } from '@pixi/mesh';\nimport { settings } from './settings';\n\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\n\nlet warned = false;\n\n/**\n * Cached tint value so we can tell when the tint is changed.\n * @memberof PIXI.Mesh#\n * @member {number} _cachedTint\n * @protected\n */\nMesh.prototype._cachedTint = 0xFFFFFF;\n\n/**\n * Cached tinted texture.\n * @memberof PIXI.Mesh#\n * @member {HTMLCanvasElement} _tintedCanvas\n * @protected\n */\nMesh.prototype._tintedCanvas = null;\n\n/**\n * The cache texture is used to generate `_tintedCanvas`.\n * @memberof PIXI.Mesh#\n * @member {PIXI.Texture} _cachedTexture\n * @protected\n */\nMesh.prototype._cachedTexture = null;\n\n/**\n * Renders the object using the Canvas renderer\n * @private\n * @method _renderCanvas\n * @memberof PIXI.Mesh#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n */\nMesh.prototype._renderCanvas = function _renderCanvas(renderer: CanvasRenderer): void\n{\n    if (this.shader.uvMatrix)\n    {\n        this.shader.uvMatrix.update();\n        this.calculateUvs();\n    }\n\n    if (this.material._renderCanvas)\n    {\n        this.material._renderCanvas(renderer, this);\n    }\n    else if (!warned)\n    {\n        warned = true;\n        if (globalThis.console)\n        {\n            console.warn('Mesh with custom shaders are not supported in CanvasRenderer.');\n        }\n    }\n};\n\n// IMPORTANT: Please do NOT use this as a precedent to use `settings` after the object is created\n// this was merely created to completely decouple canvas from the base Mesh class and we are\n// unable to add `canvasPadding` in the constructor anymore, as the case was for PixiJS v4.\n\n/**\n * Internal variable for `canvasPadding`.\n * @private\n * @memberof PIXI.Mesh\n * @member {number}\n * @default null\n */\nMesh.prototype._canvasPadding = null;\n\n/**\n * Triangles in canvas mode are automatically antialiased, use this value to force triangles\n * to overlap a bit with each other. To set the global default, set {@link PIXI.settings.MESH_CANVAS_PADDING}\n * @see PIXI.settings.MESH_CANVAS_PADDING\n * @member {number} canvasPadding\n * @memberof PIXI.SimpleMesh#\n * @default 0\n */\nObject.defineProperty(Mesh.prototype, 'canvasPadding', {\n    get()\n    {\n        return this._canvasPadding !== null ? this._canvasPadding : settings.MESH_CANVAS_PADDING;\n    },\n    set(value)\n    {\n        this._canvasPadding = value;\n    },\n});\n", "import { SimpleMesh } from '@pixi/mesh-extras';\n\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\n\n/**\n * Renders the object using the Canvas renderer\n * @private\n * @method _renderCanvas\n * @memberof PIXI.Mesh#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n */\nSimpleMesh.prototype._renderCanvas = function _renderCanvas(renderer: CanvasRenderer): void\n{\n    if (this.autoUpdate)\n    {\n        this.geometry.getBuffer('aVertexPosition').update();\n    }\n\n    if (this.shader.update)\n    {\n        this.shader.update();\n    }\n\n    this.calculateUvs();\n\n    this.material._renderCanvas(renderer, this);\n};\n", "import { SimpleRope } from '@pixi/mesh-extras';\n\nimport type { RopeGeometry } from '@pixi/mesh-extras';\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\n\n/**\n * Renders the object using the Canvas renderer\n * @protected\n * @method _renderCanvas\n * @memberof PIXI.Mesh#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n */\nSimpleRope.prototype._renderCanvas = function _renderCanvas(renderer: CanvasRenderer): void\n{\n    if (this.autoUpdate\n        || (this.geometry as RopeGeometry)._width !== this.shader.texture.height)\n    {\n        (this.geometry as RopeGeometry)._width = this.shader.texture.height;\n        (this.geometry as RopeGeometry).update();\n    }\n\n    if (this.shader.update)\n    {\n        this.shader.update();\n    }\n\n    this.calculateUvs();\n\n    this.material._renderCanvas(renderer, this);\n};\n", "/**\n * Utilities for polygon\n * @class\n * @private\n */\nexport class PolygonUtils\n{\n    /**\n     * Calculate points of an offset polygon\n     * @see {@link http://csharphelper.com/blog/2016/01/enlarge-a-polygon-in-c/}\n     * @private\n     * @param {number[]} points - polygon coordinates\n     * @param {number} offset\n     * @returns {number[]} - offset points\n     */\n    static offsetPolygon(points: number[], offset: number): number[]\n    {\n        const offsetPoints: number[] = [];\n        const length: number = points.length;\n\n        offset = PolygonUtils.isPolygonClockwise(points) ? offset : -1 * offset;\n\n        for (let j = 0; j < length; j += 2)\n        {\n            // Find location for the points before and after j\n            let i = (j - 2);\n\n            if (i < 0)\n            {\n                i += length;\n            }\n\n            const k = (j + 2) % length;\n\n            // Move the points by the offset\n            let v1x = points[j] - points[i];\n            let v1y = points[j + 1] - points[i + 1];\n            let len = Math.sqrt((v1x * v1x) + (v1y * v1y));\n\n            v1x /= len;\n            v1y /= len;\n            v1x *= offset;\n            v1y *= offset;\n\n            const norm1x = -v1y;\n            const norm1y = v1x;\n\n            const pij1 = [points[i] + norm1x, points[i + 1] + norm1y];\n            const pij2 = [points[j] + norm1x, points[j + 1] + norm1y];\n\n            let v2x = points[k] - points[j];\n            let v2y = points[k + 1] - points[j + 1];\n\n            len = Math.sqrt((v2x * v2x) + (v2y * v2y));\n\n            v2x /= len;\n            v2y /= len;\n            v2x *= offset;\n            v2y *= offset;\n\n            const norm2x = -v2y;\n            const norm2y = v2x;\n\n            const pjk1 = [points[j] + norm2x, points[j + 1] + norm2y];\n            const pjk2 = [points[k] + norm2x, points[k + 1] + norm2y];\n\n            // Find where the shifted lines ij and jk intersect.\n            const intersectPoint = PolygonUtils\n                .findIntersection(pij1[0], pij1[1], pij2[0], pij2[1], pjk1[0], pjk1[1], pjk2[0], pjk2[1]);\n\n            if (intersectPoint)\n            {\n                offsetPoints.push(...intersectPoint);\n            }\n        }\n\n        return offsetPoints;\n    }\n\n    /**\n     * Determine the intersection point of two line segments\n     * @see {@link here http://paulbourke.net/geometry/pointlineplane/}\n     * @private\n     * @param {number} x1 - x-coordinate of start point at first line\n     * @param {number} y1 - y-coordinate of start point at first line\n     * @param {number} x2 - x-coordinate of end point at first line\n     * @param {number} y2 - y-coordinate of end point at first line\n     * @param {number} x3 - x-coordinate of start point at second line\n     * @param {number} y3 - y-coordinate of start point at second line\n     * @param {number} x4 - x-coordinate of end point at second line\n     * @param {number} y4 - y-coordinate of end point at second line\n     * @returns {[number, number] | null} - [x, y] coordinates of intersection\n     */\n    static findIntersection(\n        x1: number, y1: number, x2: number, y2: number,\n        x3: number, y3: number, x4: number, y4: number\n    ): [number, number] | null\n    {\n        const denominator = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n        const numeratorA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n        const numeratorB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n\n        // lines are parallel\n        if (denominator === 0)\n        {\n            // lines are coincident\n            if (numeratorA === 0 && numeratorB === 0)\n            {\n                return [(x1 + x2) / 2, (y1 + y2) / 2];\n            }\n\n            return null;\n        }\n\n        const uA = numeratorA / denominator;\n\n        return [x1 + (uA * (x2 - x1)), y1 + (uA * (y2 - y1))];\n    }\n\n    /**\n     * Determine polygon are clockwise or counterclockwise\n     * @see {@link https://stackoverflow.com/questions/1165647}\n     * @private\n     * @param {number[]} polygon - polygon coordinates\n     * @returns {boolean} - true if polygon is clockwise\n     */\n    static isPolygonClockwise(polygon: number[]): boolean\n    {\n        let sum = 0;\n\n        for (let i = 0, j = polygon.length - 2; i < polygon.length; j = i, i += 2)\n        {\n            sum += (polygon[i] - polygon[j]) * (polygon[i + 1] + polygon[j + 1]);\n        }\n\n        return sum > 0;\n    }\n}\n", "import type { ExtensionMetadata } from '@pixi/core';\nimport { ExtensionType, Texture } from '@pixi/core';\nimport { SHAPES, Matrix } from '@pixi/math';\nimport { canvasUtils } from '@pixi/canvas-renderer';\nimport type { CanvasRenderer, CrossPlatformCanvasRenderingContext2D } from '@pixi/canvas-renderer';\nimport type { FillStyle, Graphics, GraphicsData, LineStyle } from '@pixi/graphics';\nimport type { Circle, Ellipse, Polygon, Rectangle, RoundedRectangle } from '@pixi/math';\nimport { PolygonUtils } from './utils/PolygonUtils';\n\n/*\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they\n * now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's CanvasGraphicsRenderer:\n * https://github.com/libgdx/libgdx/blob/1.0.0/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java\n */\n\n/**\n * Renderer dedicated to drawing and batching graphics objects.\n * @class\n * @protected\n * @memberof PIXI\n */\nexport class CanvasGraphicsRenderer\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'graphics',\n        type: ExtensionType.CanvasRendererPlugin,\n    };\n\n    /** A reference to the current renderer */\n    public renderer: CanvasRenderer;\n    private _svgMatrix: DOMMatrix | boolean = null;\n    private _tempMatrix: Matrix = new Matrix();\n\n    /**\n     * @param renderer - A reference to the current renderer.\n     */\n    constructor(renderer: CanvasRenderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * calculates fill/stroke style for canvas\n     * @private\n     * @param style - A graphics {@link PIXI.FILL_STYLE} where if `texture` is specified then a tinted CanvasPattern\n     * will be used for the fill.stroke\n     * @param tint - color to set the fill/stroke too.\n     */\n    private _calcCanvasStyle(style: FillStyle, tint: number): string | CanvasPattern\n    {\n        let res;\n\n        if (style.texture && style.texture.baseTexture !== Texture.WHITE.baseTexture)\n        {\n            if (style.texture.valid)\n            {\n                res = canvasUtils.getTintedPattern(style.texture, tint);\n                this.setPatternTransform(res, style.matrix || Matrix.IDENTITY);\n            }\n            else\n            {\n                res = '#808080';\n            }\n        }\n        else\n        {\n            res = `#${(`00000${(tint | 0).toString(16)}`).slice(-6)}`;\n        }\n\n        return res;\n    }\n\n    /**\n     * Renders a Graphics object to a canvas.\n     * @param graphics - the actual graphics object to render\n     */\n    public render(graphics: Graphics): void\n    {\n        const renderer = this.renderer;\n        const context = renderer.context;\n        const worldAlpha = graphics.worldAlpha;\n        const transform = graphics.transform.worldTransform;\n\n        renderer.setContextTransform(transform);\n        renderer.setBlendMode(graphics.blendMode);\n\n        const graphicsData = graphics.geometry.graphicsData;\n\n        let contextFillStyle;\n        let contextStrokeStyle;\n\n        const tintR = ((graphics.tint >> 16) & 0xFF) / 255;\n        const tintG = ((graphics.tint >> 8) & 0xFF) / 255;\n        const tintB = (graphics.tint & 0xFF) / 255;\n\n        for (let i = 0; i < graphicsData.length; i++)\n        {\n            const data = graphicsData[i];\n            const shape = data.shape;\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n\n            const fillColor = data.fillStyle.color | 0;\n            const lineColor = data.lineStyle.color | 0;\n\n            if (data.matrix)\n            {\n                renderer.setContextTransform(transform.copyTo(this._tempMatrix).append(data.matrix));\n            }\n\n            if (fillStyle.visible)\n            {\n                const fillTint = (\n                    (((fillColor >> 16) & 0xFF) / 255 * tintR * 255 << 16)\n                    + (((fillColor >> 8) & 0xFF) / 255 * tintG * 255 << 8)\n                    + (((fillColor & 0xFF) / 255) * tintB * 255)\n                );\n\n                contextFillStyle = this._calcCanvasStyle(fillStyle, fillTint);\n            }\n            if (lineStyle.visible)\n            {\n                const lineTint = (\n                    (((lineColor >> 16) & 0xFF) / 255 * tintR * 255 << 16)\n                    + (((lineColor >> 8) & 0xFF) / 255 * tintG * 255 << 8)\n                    + (((lineColor & 0xFF) / 255) * tintB * 255)\n                );\n\n                contextStrokeStyle = this._calcCanvasStyle(lineStyle, lineTint);\n            }\n\n            context.lineWidth = lineStyle.width;\n            context.lineCap = lineStyle.cap;\n            context.lineJoin = lineStyle.join;\n            context.miterLimit = lineStyle.miterLimit;\n\n            if (data.type === SHAPES.POLY)\n            {\n                context.beginPath();\n\n                const tempShape = shape as Polygon;\n                let points = tempShape.points;\n                const holes = data.holes;\n                let outerArea;\n                let innerArea;\n                let px;\n                let py;\n                let holesDirection: boolean[];\n\n                context.moveTo(points[0], points[1]);\n\n                for (let j = 2; j < points.length; j += 2)\n                {\n                    context.lineTo(points[j], points[j + 1]);\n                }\n\n                if (tempShape.closeStroke)\n                {\n                    context.closePath();\n                }\n\n                if (holes.length > 0)\n                {\n                    holesDirection = [];\n                    outerArea = 0;\n                    px = points[0];\n                    py = points[1];\n                    for (let j = 2; j + 2 < points.length; j += 2)\n                    {\n                        outerArea += ((points[j] - px) * (points[j + 3] - py))\n                            - ((points[j + 2] - px) * (points[j + 1] - py));\n                    }\n\n                    for (let k = 0; k < holes.length; k++)\n                    {\n                        points = (holes[k].shape as Polygon).points;\n\n                        if (!points)\n                        {\n                            continue;\n                        }\n\n                        innerArea = 0;\n                        px = points[0];\n                        py = points[1];\n                        for (let j = 2; j + 2 < points.length; j += 2)\n                        {\n                            innerArea += ((points[j] - px) * (points[j + 3] - py))\n                                - ((points[j + 2] - px) * (points[j + 1] - py));\n                        }\n\n                        if (innerArea * outerArea < 0)\n                        {\n                            context.moveTo(points[0], points[1]);\n\n                            for (let j = 2; j < points.length; j += 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n                        else\n                        {\n                            context.moveTo(points[points.length - 2], points[points.length - 1]);\n\n                            for (let j = points.length - 4; j >= 0; j -= 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n\n                        if ((holes[k].shape as Polygon).closeStroke)\n                        {\n                            context.closePath();\n                        }\n\n                        holesDirection[k] = innerArea * outerArea < 0;\n                    }\n                }\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = contextFillStyle;\n                    context.fill();\n                }\n\n                if (lineStyle.visible)\n                {\n                    this.paintPolygonStroke(\n                        tempShape, lineStyle, contextStrokeStyle, holes, holesDirection, worldAlpha, context\n                    );\n                }\n            }\n            else if (data.type === SHAPES.RECT)\n            {\n                const tempShape = shape as Rectangle;\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = contextFillStyle;\n                    context.fillRect(tempShape.x, tempShape.y, tempShape.width, tempShape.height);\n                }\n\n                if (lineStyle.visible)\n                {\n                    const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n                    const width = tempShape.width + (2 * alignmentOffset);\n                    const height = tempShape.height + (2 * alignmentOffset);\n\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.strokeRect(tempShape.x - alignmentOffset, tempShape.y - alignmentOffset, width, height);\n                }\n            }\n            else if (data.type === SHAPES.CIRC)\n            {\n                const tempShape = shape as Circle;\n\n                // TODO - need to be Undefined!\n                context.beginPath();\n                context.arc(tempShape.x, tempShape.y, tempShape.radius, 0, 2 * Math.PI);\n                context.closePath();\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = contextFillStyle;\n                    context.fill();\n                }\n\n                if (lineStyle.visible)\n                {\n                    if (lineStyle.alignment !== 0.5)\n                    {\n                        const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n\n                        context.beginPath();\n                        context.arc(tempShape.x, tempShape.y, tempShape.radius + alignmentOffset, 0, 2 * Math.PI);\n                        context.closePath();\n                    }\n\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.stroke();\n                }\n            }\n            else if (data.type === SHAPES.ELIP)\n            {\n                const tempShape = shape as Ellipse;\n                const drawShapeOverStroke = lineStyle.alignment === 1;\n\n                if (!drawShapeOverStroke)\n                {\n                    this.paintEllipse(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);\n                }\n\n                if (lineStyle.visible)\n                {\n                    if (lineStyle.alignment !== 0.5)\n                    {\n                        const kappa = 0.5522848;\n                        const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n                        const sW = (tempShape.width + alignmentOffset) * 2;\n                        const sH = (tempShape.height + alignmentOffset) * 2;\n                        const sX = tempShape.x - (sW / 2);\n                        const sY = tempShape.y - (sH / 2);\n                        const sOx = (sW / 2) * kappa;\n                        const sOy = (sH / 2) * kappa;\n                        const sXe = sX + sW;\n                        const sYe = sY + sH;\n                        const sXm = sX + (sW / 2);\n                        const sYm = sY + (sH / 2);\n\n                        context.beginPath();\n                        context.moveTo(sX, sYm);\n                        context.bezierCurveTo(sX, sYm - sOy, sXm - sOx, sY, sXm, sY);\n                        context.bezierCurveTo(sXm + sOx, sY, sXe, sYm - sOy, sXe, sYm);\n                        context.bezierCurveTo(sXe, sYm + sOy, sXm + sOx, sYe, sXm, sYe);\n                        context.bezierCurveTo(sXm - sOx, sYe, sX, sYm + sOy, sX, sYm);\n                        context.closePath();\n                    }\n\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.stroke();\n                }\n\n                if (drawShapeOverStroke)\n                {\n                    this.paintEllipse(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);\n                }\n            }\n            else if (data.type === SHAPES.RREC)\n            {\n                const tempShape = shape as RoundedRectangle;\n                const drawShapeOverStroke = lineStyle.alignment === 1;\n\n                if (!drawShapeOverStroke)\n                {\n                    this.paintRoundedRectangle(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);\n                }\n\n                if (lineStyle.visible)\n                {\n                    if (lineStyle.alignment !== 0.5)\n                    {\n                        const width = tempShape.width;\n                        const height = tempShape.height;\n                        const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n                        const sRx = tempShape.x - alignmentOffset;\n                        const sRy = tempShape.y - alignmentOffset;\n                        const sWidth = tempShape.width + (2 * alignmentOffset);\n                        const sHeight = tempShape.height + (2 * alignmentOffset);\n                        const radiusOffset = alignmentOffset * (lineStyle.alignment >= 1\n                            ? Math.min(sWidth / width, sHeight / height) : Math.min(width / sWidth, height / sHeight));\n                        let sRadius = tempShape.radius + radiusOffset;\n                        const sMaxRadius = Math.min(sWidth, sHeight) / 2;\n\n                        sRadius = sRadius > sMaxRadius ? sMaxRadius : sRadius;\n\n                        context.beginPath();\n                        context.moveTo(sRx, sRy + sRadius);\n                        context.lineTo(sRx, sRy + sHeight - sRadius);\n                        context.quadraticCurveTo(sRx, sRy + sHeight, sRx + sRadius, sRy + sHeight);\n                        context.lineTo(sRx + sWidth - sRadius, sRy + sHeight);\n                        context.quadraticCurveTo(sRx + sWidth, sRy + sHeight, sRx + sWidth, sRy + sHeight - sRadius);\n                        context.lineTo(sRx + sWidth, sRy + sRadius);\n                        context.quadraticCurveTo(sRx + sWidth, sRy, sRx + sWidth - sRadius, sRy);\n                        context.lineTo(sRx + sRadius, sRy);\n                        context.quadraticCurveTo(sRx, sRy, sRx, sRy + sRadius);\n                        context.closePath();\n                    }\n\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.stroke();\n                }\n\n                if (drawShapeOverStroke)\n                {\n                    this.paintRoundedRectangle(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);\n                }\n            }\n        }\n    }\n\n    /**\n     * Paint stroke for polygon and holes\n     * @private\n     * @param shape - Shape to be drawn\n     * @param lineStyle - Line style for the shape\n     * @param contextStrokeStyle - The strokeStyle for the canvas context\n     * @param holes - Holes to be added to the shape\n     * @param holesDirection -\n     * @param worldAlpha - The multiplied alpha of the displayObject\n     * @param context - The canvas context\n     */\n    private paintPolygonStroke(\n        shape: Polygon, lineStyle: LineStyle, contextStrokeStyle: string | CanvasPattern,\n        holes: GraphicsData[], holesDirection: boolean[],\n        worldAlpha: number, context: CrossPlatformCanvasRenderingContext2D\n    ): void\n    {\n        if (lineStyle.alignment !== 0.5)\n        {\n            const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n            let offsetPoints = PolygonUtils.offsetPolygon(shape.points, alignmentOffset);\n            let points;\n\n            context.beginPath();\n            context.moveTo(offsetPoints[0], offsetPoints[1]);\n\n            for (let j = 2; j < offsetPoints.length; j += 2)\n            {\n                context.lineTo(offsetPoints[j], offsetPoints[j + 1]);\n            }\n\n            if (shape.closeStroke)\n            {\n                context.closePath();\n            }\n\n            for (let k = 0; k < holes.length; k++)\n            {\n                points = (holes[k].shape as Polygon).points;\n                offsetPoints = PolygonUtils.offsetPolygon(points, alignmentOffset);\n\n                if (holesDirection[k])\n                {\n                    context.moveTo(offsetPoints[0], offsetPoints[1]);\n\n                    for (let j = 2; j < offsetPoints.length; j += 2)\n                    {\n                        context.lineTo(offsetPoints[j], offsetPoints[j + 1]);\n                    }\n                }\n                else\n                {\n                    context.moveTo(offsetPoints[offsetPoints.length - 2], offsetPoints[offsetPoints.length - 1]);\n\n                    for (let j = offsetPoints.length - 4; j >= 0; j -= 2)\n                    {\n                        context.lineTo(offsetPoints[j], offsetPoints[j + 1]);\n                    }\n                }\n\n                if ((holes[k].shape as Polygon).closeStroke)\n                {\n                    context.closePath();\n                }\n            }\n        }\n\n        context.globalAlpha = lineStyle.alpha * worldAlpha;\n        context.strokeStyle = contextStrokeStyle;\n        context.stroke();\n    }\n\n    /**\n     * Paint Ellipse\n     * @private\n     * @param shape - Shape to be drawn\n     * @param fillStyle - Fill for the shape\n     * @param lineStyle - Line style for the shape\n     * @param contextFillStyle - The canvas context fill style\n     * @param worldAlpha - The multiplied alpha of the displayObject\n     * @param context - The canvas context\n     */\n    private paintEllipse(\n        shape: Ellipse, fillStyle: FillStyle, lineStyle: LineStyle,\n        contextFillStyle: string | CanvasPattern, worldAlpha: number,\n        context: CrossPlatformCanvasRenderingContext2D): void\n    {\n        // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n        const w = shape.width * 2;\n        const h = shape.height * 2;\n\n        const x = shape.x - (w / 2);\n        const y = shape.y - (h / 2);\n\n        const kappa = 0.5522848;\n        const ox = (w / 2) * kappa; // control point offset horizontal\n        const oy = (h / 2) * kappa; // control point offset vertical\n        const xe = x + w; // x-end\n        const ye = y + h; // y-end\n        const xm = x + (w / 2); // x-middle\n        const ym = y + (h / 2); // y-middle\n\n        if (lineStyle.alignment === 0)\n        {\n            context.save();\n        }\n\n        context.beginPath();\n        context.moveTo(x, ym);\n        context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n        context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n        context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n        context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n        context.closePath();\n\n        if (lineStyle.alignment === 0)\n        {\n            context.clip();\n        }\n\n        if (fillStyle.visible)\n        {\n            context.globalAlpha = fillStyle.alpha * worldAlpha;\n            context.fillStyle = contextFillStyle;\n            context.fill();\n        }\n\n        if (lineStyle.alignment === 0)\n        {\n            context.restore();\n        }\n    }\n\n    /**\n     * Paint Rounded Rectangle\n     * @private\n     * @param shape - Shape to be drawn\n     * @param fillStyle - Fill for the shape\n     * @param lineStyle - Line style for the shape\n     * @param contextFillStyle - The canvas context fill style\n     * @param worldAlpha - The multiplied alpha of the displayObject\n     * @param context - The canvas context\n     */\n    private paintRoundedRectangle(\n        shape: RoundedRectangle, fillStyle: FillStyle, lineStyle: LineStyle,\n        contextFillStyle: string | CanvasPattern, worldAlpha: number,\n        context: CrossPlatformCanvasRenderingContext2D\n    ): void\n    {\n        const rx = shape.x;\n        const ry = shape.y;\n        const width = shape.width;\n        const height = shape.height;\n        let radius = shape.radius;\n\n        const maxRadius = Math.min(width, height) / 2;\n\n        radius = radius > maxRadius ? maxRadius : radius;\n\n        if (lineStyle.alignment === 0)\n        {\n            context.save();\n        }\n\n        context.beginPath();\n        context.moveTo(rx, ry + radius);\n        context.lineTo(rx, ry + height - radius);\n        context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n        context.lineTo(rx + width - radius, ry + height);\n        context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n        context.lineTo(rx + width, ry + radius);\n        context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n        context.lineTo(rx + radius, ry);\n        context.quadraticCurveTo(rx, ry, rx, ry + radius);\n        context.closePath();\n\n        if (lineStyle.alignment === 0)\n        {\n            context.clip();\n        }\n\n        if (fillStyle.visible)\n        {\n            context.globalAlpha = fillStyle.alpha * worldAlpha;\n            context.fillStyle = contextFillStyle;\n            context.fill();\n        }\n\n        if (lineStyle.alignment === 0)\n        {\n            context.restore();\n        }\n    }\n\n    public setPatternTransform(pattern: CanvasPattern, matrix: Matrix): void\n    {\n        if (this._svgMatrix === false)\n        {\n            return;\n        }\n        if (!this._svgMatrix)\n        {\n            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\n            if (svg && svg.createSVGMatrix)\n            {\n                this._svgMatrix = svg.createSVGMatrix();\n            }\n            if (!this._svgMatrix || !pattern.setTransform)\n            {\n                this._svgMatrix = false;\n\n                return;\n            }\n        }\n\n        (this._svgMatrix as DOMMatrix).a = matrix.a;\n        (this._svgMatrix as DOMMatrix).b = matrix.b;\n        (this._svgMatrix as DOMMatrix).c = matrix.c;\n        (this._svgMatrix as DOMMatrix).d = matrix.d;\n        (this._svgMatrix as DOMMatrix).e = matrix.tx;\n        (this._svgMatrix as DOMMatrix).f = matrix.ty;\n        pattern.setTransform((this._svgMatrix as DOMMatrix).inverse());\n    }\n\n    /** destroy graphics object */\n    public destroy(): void\n    {\n        this.renderer = null;\n        this._svgMatrix = null;\n        this._tempMatrix = null;\n    }\n}\n", "import { Graphics } from '@pixi/graphics';\nimport { CanvasRenderer } from '@pixi/canvas-renderer';\nimport { RenderTexture, Texture } from '@pixi/core';\nimport { Matrix } from '@pixi/math';\n\nimport type { SCALE_MODES } from '@pixi/constants';\nimport type { BaseRenderTexture } from '@pixi/core';\n\nlet canvasRenderer: CanvasRenderer;\nconst tempMatrix = new Matrix();\n\n/**\n * Generates a canvas texture. Only available with **pixi.js-legacy** bundle\n * or the **@pixi/canvas-graphics** package.\n * @method generateCanvasTexture\n * @memberof PIXI.Graphics#\n * @param {PIXI.SCALE_MODES} [scaleMode] - The scale mode of the texture.\n * @param {number} resolution - The resolution of the texture.\n * @returns {PIXI.Texture} The new texture.\n */\nGraphics.prototype.generateCanvasTexture = function generateCanvasTexture(scaleMode?: SCALE_MODES, resolution = 1): Texture\n{\n    const bounds = this.getLocalBounds();\n\n    const canvasBuffer = RenderTexture.create({\n        width: bounds.width,\n        height: bounds.height,\n        scaleMode,\n        resolution,\n    });\n\n    if (!canvasRenderer)\n    {\n        canvasRenderer = new CanvasRenderer();\n    }\n\n    this.transform.updateLocalTransform();\n    this.transform.localTransform.copyTo(tempMatrix);\n\n    tempMatrix.invert();\n\n    tempMatrix.tx -= bounds.x;\n    tempMatrix.ty -= bounds.y;\n\n    canvasRenderer.render(this, { renderTexture: canvasBuffer, clear: true, transform: tempMatrix });\n\n    const texture = Texture.from((canvasBuffer.baseTexture as BaseRenderTexture)._canvasRenderTarget.canvas, {\n        scaleMode,\n    });\n\n    texture.baseTexture.setResolution(resolution);\n\n    return texture;\n};\n\nGraphics.prototype.cachedGraphicsData = [];\n\n/**\n * Renders the object using the Canvas renderer\n * @method _renderCanvas\n * @memberof PIXI.Graphics#\n * @private\n * @param {PIXI.CanvasRenderer} renderer - The renderer\n */\nGraphics.prototype._renderCanvas = function _renderCanvas(renderer: CanvasRenderer): void\n{\n    if (this.isMask === true)\n    {\n        return;\n    }\n\n    this.finishPoly();\n    renderer.plugins.graphics.render(this);\n};\n", "import { SCALE_MODES, BLEND_MODES } from '@pixi/constants';\nimport { Matrix, groupD8 } from '@pixi/math';\nimport { canvasUtils } from '@pixi/canvas-renderer';\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\nimport type { Sprite } from '@pixi/sprite';\nimport type { ExtensionMetadata } from '@pixi/core';\nimport { ExtensionType } from '@pixi/core';\n\nconst canvasRenderWorldTransform = new Matrix();\n\n/**\n * Types that can be passed to drawImage\n * @typedef {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap} ICanvasImageSource\n * @memberof PIXI\n */\n\n/*\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now\n * share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's CanvasSpriteRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/CanvasSpriteRenderer.java\n */\n\n/**\n * Renderer dedicated to drawing and batching sprites.\n * @class\n * @protected\n * @memberof PIXI\n */\nexport class CanvasSpriteRenderer\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'sprite',\n        type: ExtensionType.CanvasRendererPlugin,\n    };\n\n    /** A reference to the current renderer */\n    protected renderer: CanvasRenderer;\n\n    /** @param renderer - A reference to the current renderer */\n    constructor(renderer: CanvasRenderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * Renders the sprite object.\n     * @param sprite - the sprite to render when using this spritebatch\n     */\n    render(sprite: Sprite): void\n    {\n        const texture = sprite._texture;\n        const renderer = this.renderer;\n        const context = renderer.context;\n\n        if (!texture.valid)\n        {\n            return;\n        }\n\n        const sourceWidth = texture._frame.width;\n        const sourceHeight = texture._frame.height;\n\n        let destWidth = texture._frame.width;\n        let destHeight = texture._frame.height;\n\n        if (texture.trim)\n        {\n            if (groupD8.isVertical(texture.rotate))\n            {\n                destWidth = texture.trim.height;\n                destHeight = texture.trim.width;\n            }\n            else\n            {\n                destWidth = texture.trim.width;\n                destHeight = texture.trim.height;\n            }\n        }\n\n        let wt = sprite.transform.worldTransform;\n        let dx = 0;\n        let dy = 0;\n\n        const source = texture.baseTexture.getDrawableSource();\n\n        if (texture.orig.width <= 0 || texture.orig.height <= 0 || !texture.valid || !source)\n        {\n            return;\n        }\n\n        renderer.setBlendMode(sprite.blendMode, true);\n\n        renderer.context.globalAlpha = sprite.worldAlpha;\n\n        // If smoothingEnabled is supported and we need to change the smoothing property for sprite texture\n        const smoothingEnabled = texture.baseTexture.scaleMode === SCALE_MODES.LINEAR;\n\n        if (renderer.smoothProperty\n            && renderer.context[renderer.smoothProperty] !== smoothingEnabled)\n        {\n            context[renderer.smoothProperty] = smoothingEnabled;\n        }\n\n        if (texture.trim)\n        {\n            dx = (texture.trim.width / 2) + texture.trim.x - (sprite.anchor.x * texture.orig.width);\n            dy = (texture.trim.height / 2) + texture.trim.y - (sprite.anchor.y * texture.orig.height);\n        }\n        else\n        {\n            dx = (0.5 - sprite.anchor.x) * texture.orig.width;\n            dy = (0.5 - sprite.anchor.y) * texture.orig.height;\n        }\n\n        if (texture.rotate)\n        {\n            wt.copyTo(canvasRenderWorldTransform);\n            wt = canvasRenderWorldTransform;\n            groupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy);\n            // the anchor has already been applied above, so lets set it to zero\n            dx = 0;\n            dy = 0;\n        }\n\n        dx -= destWidth / 2;\n        dy -= destHeight / 2;\n\n        renderer.setContextTransform(wt, sprite.roundPixels, 1);\n        // Allow for pixel rounding\n        if (sprite.roundPixels)\n        {\n            dx = dx | 0;\n            dy = dy | 0;\n        }\n\n        const resolution = texture.baseTexture.resolution;\n        const outerBlend = renderer._outerBlend;\n\n        if (outerBlend)\n        {\n            context.save();\n            context.beginPath();\n            context.rect(\n                dx * renderer.resolution,\n                dy * renderer.resolution,\n                destWidth * renderer.resolution,\n                destHeight * renderer.resolution\n            );\n            context.clip();\n        }\n\n        if (sprite.tint !== 0xFFFFFF)\n        {\n            if (sprite._cachedTint !== sprite.tint || sprite._tintedCanvas.tintId !== sprite._texture._updateID)\n            {\n                sprite._cachedTint = sprite.tint;\n\n                // TODO clean up caching - how to clean up the caches?\n                sprite._tintedCanvas = canvasUtils.getTintedCanvas(sprite, sprite.tint);\n            }\n\n            context.drawImage(\n                sprite._tintedCanvas,\n                0,\n                0,\n                Math.floor(sourceWidth * resolution),\n                Math.floor(sourceHeight * resolution),\n                Math.floor(dx * renderer.resolution),\n                Math.floor(dy * renderer.resolution),\n                Math.floor(destWidth * renderer.resolution),\n                Math.floor(destHeight * renderer.resolution)\n            );\n        }\n        else\n        {\n            context.drawImage(\n                source,\n                texture._frame.x * resolution,\n                texture._frame.y * resolution,\n                Math.floor(sourceWidth * resolution),\n                Math.floor(sourceHeight * resolution),\n                Math.floor(dx * renderer.resolution),\n                Math.floor(dy * renderer.resolution),\n                Math.floor(destWidth * renderer.resolution),\n                Math.floor(destHeight * renderer.resolution)\n            );\n        }\n\n        if (outerBlend)\n        {\n            context.restore();\n        }\n        // just in case, leaking outer blend here will be catastrophic!\n        renderer.setBlendMode(BLEND_MODES.NORMAL);\n    }\n\n    /** destroy the sprite object */\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n}\n", "import { Sprite } from '@pixi/sprite';\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\n\n/**\n * Cached tinted texture.\n * @memberof PIXI.Sprite#\n * @member {HTMLCanvasElement} _tintedCanvas\n * @protected\n */\nSprite.prototype._tintedCanvas = null;\n\n/**\n * Renders the object using the Canvas renderer\n * @private\n * @method _renderCanvas\n * @memberof PIXI.Sprite#\n * @param {PIXI.CanvasRenderer} renderer - The renderer\n */\nSprite.prototype._renderCanvas = function _renderCanvas(renderer: CanvasRenderer): void\n{\n    renderer.plugins.sprite.render(this);\n};\n", "import { ExtensionType, RenderTexture } from '@pixi/core';\nimport { CanvasRenderTarget } from '@pixi/utils';\nimport { Rectangle } from '@pixi/math';\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\nimport type { DisplayObject } from '@pixi/display';\nimport type { BaseRenderTexture, ExtensionMetadata } from '@pixi/core';\n\nconst TEMP_RECT = new Rectangle();\n\n/**\n * The extract manager provides functionality to export content from the renderers.\n *\n * An instance of this class is automatically created by default, and can be found at `renderer.plugins.extract`\n * @class\n * @memberof PIXI\n */\nexport class CanvasExtract\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'extract',\n        type: ExtensionType.CanvasRendererPlugin,\n    };\n\n    /** A reference to the current renderer */\n    public renderer: CanvasRenderer;\n\n    /**\n     * @param renderer - A reference to the current renderer\n     */\n    constructor(renderer: CanvasRenderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * Will return a HTML Image of the target\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param format - Image format, e.g. \"image/jpeg\" or \"image/webp\".\n     * @param quality - JPEG or Webp compression from 0 to 1. Default is 0.92.\n     * @returns HTML Image of the target\n     */\n    public image(target?: DisplayObject | RenderTexture, format?: string, quality?: number): HTMLImageElement\n    {\n        const image = new Image();\n\n        image.src = this.base64(target, format, quality);\n\n        return image;\n    }\n\n    /**\n     * Will return a base64 encoded string of this target. It works by calling\n     *  `CanvasExtract.getCanvas` and then running toDataURL on that.\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param format - Image format, e.g. \"image/jpeg\" or \"image/webp\".\n     * @param quality - JPEG or Webp compression from 0 to 1. Default is 0.92.\n     * @returns A base64 encoded string of the texture.\n     */\n    public base64(target?: DisplayObject | RenderTexture, format?: string, quality?: number): string\n    {\n        return this.canvas(target).toDataURL(format, quality);\n    }\n\n    /**\n     * Creates a Canvas element, renders this target to it and then returns it.\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param frame - The frame the extraction is restricted to.\n     * @returns A Canvas element with the texture rendered on.\n     */\n    public canvas(target?: DisplayObject | RenderTexture, frame?: Rectangle): HTMLCanvasElement\n    {\n        const renderer = this.renderer;\n        let context;\n        let resolution;\n        let renderTexture;\n\n        if (target)\n        {\n            if (target instanceof RenderTexture)\n            {\n                renderTexture = target;\n            }\n            else\n            {\n                renderTexture = renderer.generateTexture(target);\n            }\n        }\n\n        if (renderTexture)\n        {\n            context = (renderTexture.baseTexture as BaseRenderTexture)._canvasRenderTarget.context;\n            resolution = (renderTexture.baseTexture as BaseRenderTexture)._canvasRenderTarget.resolution;\n            frame = frame ?? renderTexture.frame;\n        }\n        else\n        {\n            context = renderer.rootContext;\n            resolution = renderer.resolution;\n\n            if (!frame)\n            {\n                frame = TEMP_RECT;\n                frame.width = renderer.width;\n                frame.height = renderer.height;\n            }\n        }\n\n        const x = Math.round(frame.x * resolution);\n        const y = Math.round(frame.y * resolution);\n        const width = Math.round(frame.width * resolution);\n        const height = Math.round(frame.height * resolution);\n\n        const canvasBuffer = new CanvasRenderTarget(width, height, 1);\n        const canvasData = context.getImageData(x, y, width, height);\n\n        canvasBuffer.context.putImageData(canvasData, 0, 0);\n\n        // send the canvas back..\n        return canvasBuffer.canvas;\n    }\n\n    /**\n     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n     * order, with integer values between 0 and 255 (included).\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param frame - The frame the extraction is restricted to.\n     * @returns One-dimensional array containing the pixel data of the entire texture\n     */\n    public pixels(target?: DisplayObject | RenderTexture, frame?: Rectangle): Uint8ClampedArray\n    {\n        const renderer = this.renderer;\n        let context;\n        let resolution;\n        let renderTexture;\n\n        if (target)\n        {\n            if (target instanceof RenderTexture)\n            {\n                renderTexture = target;\n            }\n            else\n            {\n                renderTexture = renderer.generateTexture(target);\n            }\n        }\n\n        if (renderTexture)\n        {\n            context = (renderTexture.baseTexture as BaseRenderTexture)._canvasRenderTarget.context;\n            resolution = (renderTexture.baseTexture as BaseRenderTexture)._canvasRenderTarget.resolution;\n            frame = frame ?? renderTexture.frame;\n        }\n        else\n        {\n            context = renderer.rootContext;\n            resolution = renderer.resolution;\n\n            if (!frame)\n            {\n                frame = TEMP_RECT;\n                frame.width = renderer.width;\n                frame.height = renderer.height;\n            }\n        }\n\n        const x = Math.round(frame.x * resolution);\n        const y = Math.round(frame.y * resolution);\n        const width = Math.round(frame.width * resolution);\n        const height = Math.round(frame.height * resolution);\n\n        return context.getImageData(x, y, width, height).data;\n    }\n\n    /** Destroys the extract */\n    public destroy(): void\n    {\n        this.renderer = null;\n    }\n}\n", "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n", "import { BaseTexture, ExtensionType } from '@pixi/core';\nimport { BasePrepare } from '@pixi/prepare';\nimport { settings } from '@pixi/settings';\n\nimport type { AbstractRenderer, ExtensionMetadata } from '@pixi/core';\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\nimport type { IDisplayObjectExtended } from '@pixi/prepare';\n\nconst CANVAS_START_SIZE = 16;\n\n/**\n * Built-in hook to upload PIXI.Texture objects to the GPU.\n * @private\n * @param prepare - Instance of CanvasPrepare\n * @param item - Item to check\n * @returns If item was uploaded.\n */\nfunction uploadBaseTextures(prepare: AbstractRenderer | BasePrepare, item: IDisplayObjectExtended): boolean\n{\n    const tempPrepare = prepare as CanvasPrepare;\n\n    if (item instanceof BaseTexture)\n    {\n        const image = (item as any).source;\n\n        // Sometimes images (like atlas images) report a size of zero, causing errors on windows phone.\n        // So if the width or height is equal to zero then use the canvas size\n        // Otherwise use whatever is smaller, the image dimensions or the canvas dimensions.\n        const imageWidth = image.width === 0 ? tempPrepare.canvas.width : Math.min(tempPrepare.canvas.width, image.width);\n        const imageHeight = image.height === 0 ? tempPrepare.canvas.height\n            : Math.min(tempPrepare.canvas.height, image.height);\n\n        // Only a small subsections is required to be drawn to have the whole texture uploaded to the GPU\n        // A smaller draw can be faster.\n        tempPrepare.ctx.drawImage(\n            image, 0, 0, imageWidth, imageHeight, 0, 0,\n            tempPrepare.canvas.width, tempPrepare.canvas.height\n        );\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * The prepare manager provides functionality to upload content to the GPU.\n *\n * This cannot be done directly for Canvas like in WebGL, but the effect can be achieved by drawing\n * textures to an offline canvas. This draw call will force the texture to be moved onto the GPU.\n *\n * An instance of this class is automatically created by default, and can be found at `renderer.plugins.prepare`\n * @class\n * @extends PIXI.BasePrepare\n * @memberof PIXI\n */\nexport class CanvasPrepare extends BasePrepare\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'prepare',\n        type: ExtensionType.CanvasRendererPlugin,\n    };\n\n    /**\n     * An offline canvas to render textures to\n     * @internal\n     */\n    canvas: HTMLCanvasElement;\n    /**\n     * The context to the canvas\n     * @internal\n     */\n    ctx: CanvasRenderingContext2D;\n\n    /**\n     * @param renderer - A reference to the current renderer\n     */\n    constructor(renderer: CanvasRenderer)\n    {\n        super(renderer);\n\n        this.uploadHookHelper = this;\n\n        this.canvas = settings.ADAPTER.createCanvas(\n            CANVAS_START_SIZE,\n            CANVAS_START_SIZE\n        );\n\n        this.ctx = this.canvas.getContext('2d');\n\n        // Add textures to upload\n        this.registerUploadHook(uploadBaseTextures);\n    }\n\n    /** Destroys the plugin, don't use after this */\n    public destroy(): void\n    {\n        super.destroy();\n        this.ctx = null;\n        this.canvas = null;\n    }\n}\n", "import { TilingSprite } from '@pixi/sprite-tiling';\nimport { canvasUtils } from '@pixi/canvas-renderer';\nimport { CanvasRenderTarget } from '@pixi/utils';\nimport { Matrix, Point } from '@pixi/math';\n\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\n\nconst worldMatrix = new Matrix();\nconst patternMatrix = new Matrix();\nconst patternRect = [new Point(), new Point(), new Point(), new Point()];\n\n/**\n * Renders the object using the Canvas renderer\n * @protected\n * @function _renderCanvas\n * @memberof PIXI.TilingSprite#\n * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer\n */\nTilingSprite.prototype._renderCanvas = function _renderCanvas(renderer: CanvasRenderer): void\n{\n    const texture = this._texture;\n\n    if (!texture.baseTexture.valid)\n    {\n        return;\n    }\n\n    const context = renderer.context;\n    const transform = this.worldTransform;\n    const baseTexture = texture.baseTexture;\n    const source = baseTexture.getDrawableSource();\n    const baseTextureResolution = baseTexture.resolution;\n\n    // create a nice shiny pattern!\n    if (this._textureID !== this._texture._updateID || this._cachedTint !== this.tint)\n    {\n        this._textureID = this._texture._updateID;\n        // cut an object from a spritesheet..\n        const tempCanvas = new CanvasRenderTarget(texture._frame.width,\n            texture._frame.height,\n            baseTextureResolution);\n\n        // Tint the tiling sprite\n        if (this.tint !== 0xFFFFFF)\n        {\n            this._tintedCanvas = canvasUtils.getTintedCanvas(this, this.tint) as HTMLCanvasElement;\n            tempCanvas.context.drawImage(this._tintedCanvas, 0, 0);\n        }\n        else\n        {\n            tempCanvas.context.drawImage(source,\n                -texture._frame.x * baseTextureResolution, -texture._frame.y * baseTextureResolution);\n        }\n        this._cachedTint = this.tint;\n        this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');\n    }\n\n    // set context state..\n    context.globalAlpha = this.worldAlpha;\n    renderer.setBlendMode(this.blendMode);\n\n    this.tileTransform.updateLocalTransform();\n    const lt = this.tileTransform.localTransform;\n    const W = this._width;\n    const H = this._height;\n\n    /*\n     * # Implementation Notes\n     *\n     * The tiling transform is not simply a transform on the tiling sprite's local space. If that\n     * were, the bounds of the tiling sprite would change. Rather the tile transform is a transform\n     * on the \"pattern\" coordinates each vertex is assigned.\n     *\n     * To implement the `tileTransform`, we issue drawing commands in the pattern's own space, which\n     * is defined as:\n     *\n     * Pattern_Space = Local_Space x inverse(tileTransform)\n     *\n     * In other words,\n     * Local_Space = Pattern_Space x tileTransform\n     *\n     * We draw the pattern in pattern space, because the space we draw in defines the pattern's coordinates.\n     * In other words, the pattern will always \"originate\" from (0, 0) in the space we draw in.\n     *\n     * This technique is equivalent to drawing a pattern texture, and then finding a quadrilateral that becomes\n     * the tiling sprite's local bounds under the tileTransform and mapping that onto the screen.\n     *\n     * ## uvRespectAnchor\n     *\n     * The preceding paragraph discusses the case without considering `uvRespectAnchor`. The `uvRespectAnchor` flags\n     * where the origin of the pattern space is. Assuming the tileTransform includes no translation, without\n     * loss of generality: If uvRespectAnchor = true, then\n     *\n     * Local Space (0, 0) <--> Pattern Space (0, 0) (where <--> means \"maps to\")\n     *\n     * Here the mapping is provided by trivially by the tileTransform (note tileTransform includes no translation. That\n     * means the invariant under all other transforms are the origins)\n     *\n     * Otherwise,\n     *\n     * Local Space (-localBounds.x, -localBounds.y) <--> Pattern Space (0, 0)\n     *\n     * Here the mapping is provided by the tileTransfrom PLUS some \"shift\". This shift is done POST-tileTransform. The shift\n     * is equal to the position of the top-left corner of the tiling sprite in its local space.\n     *\n     * Hence,\n     *\n     * Local_Space = Pattern_Space x tileTransform x shiftTransform\n     */\n\n    // worldMatrix is used to convert from pattern space to world space.\n    //\n    // worldMatrix = tileTransform x shiftTransform x worldTransfrom\n    //             = patternMatrix x worldTransform\n    worldMatrix.identity();\n\n    // patternMatrix is used to convert from pattern space to local space. The drawing commands are issued in pattern space\n    // and this matrix is used to inverse-map the local space vertices into it.\n    //\n    // patternMatrix = tileTransfrom x shiftTransform\n    patternMatrix.copyFrom(lt);\n\n    // Apply shiftTransform into patternMatrix. See $1.1\n    if (!this.uvRespectAnchor)\n    {\n        patternMatrix.translate(-this.anchor.x * W, -this.anchor.y * H);\n    }\n\n    patternMatrix.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);\n    worldMatrix.prepend(patternMatrix);\n    worldMatrix.prepend(transform);\n\n    renderer.setContextTransform(worldMatrix);\n\n    // Fill the pattern!\n    context.fillStyle = this._canvasPattern;\n\n    // The position in local space we are drawing the rectangle: (lx, ly, lx + W, ly + H)\n    const lx = this.anchor.x * -W;\n    const ly = this.anchor.y * -H;\n\n    // Set pattern rect in local space first.\n    patternRect[0].set(lx, ly);\n    patternRect[1].set(lx + W, ly);\n    patternRect[2].set(lx + W, ly + H);\n    patternRect[3].set(lx, ly + H);\n\n    // Map patternRect into pattern space.\n    for (let i = 0; i < 4; i++)\n    {\n        patternMatrix.applyInverse(patternRect[i], patternRect[i]);\n    }\n\n    /*\n     * # Note about verification of theory\n     *\n     * As discussed in the implementation notes, you can verify that `patternRect[0]` will always be (0, 0) in case of\n     * `uvRespectAnchor` false and tileTransform having no translation. Indeed, because the pattern origin should map\n     * to the top-left corner of the tiling sprite in its local space.\n     */\n\n    context.beginPath();\n    context.moveTo(patternRect[0].x, patternRect[0].y);\n\n    for (let i = 1; i < 4; i++)\n    {\n        context.lineTo(patternRect[i].x, patternRect[i].y);\n    }\n\n    context.closePath();\n    context.fill();\n};\n", "import { ParticleContainer } from '@pixi/particle-container';\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\n\n/**\n * Renders the object using the Canvas renderer\n * @method renderCanvas\n * @memberof PIXI.ParticleContainer#\n * @private\n * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer\n */\nParticleContainer.prototype.renderCanvas = function renderCanvas(renderer: CanvasRenderer): void\n{\n    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)\n    {\n        return;\n    }\n\n    const context = renderer.context;\n    const transform = this.worldTransform;\n    let isRotated = true;\n\n    let positionX = 0;\n    let positionY = 0;\n\n    let finalWidth = 0;\n    let finalHeight = 0;\n\n    renderer.setBlendMode(this.blendMode);\n\n    context.globalAlpha = this.worldAlpha;\n\n    this.displayObjectUpdateTransform();\n\n    for (let i = 0; i < this.children.length; ++i)\n    {\n        const child = this.children[i];\n\n        if (!child.visible)\n        {\n            continue;\n        }\n\n        if (!child._texture.valid)\n        {\n            continue;\n        }\n\n        const frame = child._texture.frame;\n\n        context.globalAlpha = this.worldAlpha * child.alpha;\n\n        if (child.rotation % (Math.PI * 2) === 0)\n        {\n            // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call\n            if (isRotated)\n            {\n                renderer.setContextTransform(transform, false, 1);\n                isRotated = false;\n            }\n\n            positionX = ((child.anchor.x) * (-frame.width * child.scale.x)) + child.position.x + 0.5;\n            positionY = ((child.anchor.y) * (-frame.height * child.scale.y)) + child.position.y + 0.5;\n\n            finalWidth = frame.width * child.scale.x;\n            finalHeight = frame.height * child.scale.y;\n        }\n        else\n        {\n            if (!isRotated)\n            {\n                isRotated = true;\n            }\n\n            child.displayObjectUpdateTransform();\n\n            const childTransform = child.worldTransform;\n\n            renderer.setContextTransform(childTransform, this.roundPixels, 1);\n\n            positionX = ((child.anchor.x) * (-frame.width)) + 0.5;\n            positionY = ((child.anchor.y) * (-frame.height)) + 0.5;\n\n            finalWidth = frame.width;\n            finalHeight = frame.height;\n        }\n\n        const resolution = child._texture.baseTexture.resolution;\n\n        context.drawImage(\n            child._texture.baseTexture.getDrawableSource(),\n            frame.x * resolution,\n            frame.y * resolution,\n            frame.width * resolution,\n            frame.height * resolution,\n            positionX * renderer.resolution,\n            positionY * renderer.resolution,\n            finalWidth * renderer.resolution,\n            finalHeight * renderer.resolution\n        );\n    }\n};\n", "import { Container } from '@pixi/display';\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\nimport type { MaskData } from '@pixi/core';\n\n/**\n * To be overridden by the subclass\n * @method _renderCanvas\n * @memberof PIXI.Container#\n * @protected\n * @param {PIXI.CanvasRenderer} _renderer - The renderer\n */\nContainer.prototype._renderCanvas = function _renderCanvas(_renderer: CanvasRenderer): void\n{\n    // this is where content itself gets rendered...\n};\n\n/**\n * Renders the object using the Canvas renderer\n * @method renderCanvas\n * @memberof PIXI.Container#\n * @param {PIXI.CanvasRenderer} renderer - The renderer\n */\nContainer.prototype.renderCanvas = function renderCanvas(renderer: CanvasRenderer): void\n{\n    // if not visible or the alpha is 0 then no need to render this\n    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n    {\n        return;\n    }\n\n    if (this._mask)\n    {\n        renderer.maskManager.pushMask(this._mask as MaskData);\n    }\n\n    this._renderCanvas(renderer);\n    for (let i = 0, j = this.children.length; i < j; ++i)\n    {\n        this.children[i].renderCanvas(renderer);\n    }\n\n    if (this._mask)\n    {\n        renderer.maskManager.popMask(renderer);\n    }\n};\n", "import { DisplayObject } from '@pixi/display';\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\n\n/**\n * Renders the object using the Canvas renderer\n * @method renderCanvas\n * @memberof PIXI.Container#\n * @param {PIXI.CanvasRenderer} _renderer - The renderer\n */\nDisplayObject.prototype.renderCanvas = function renderCanvas(_renderer: CanvasRenderer): void\n{\n    // OVERWRITE;\n};\n", "import { Text } from '@pixi/text';\nimport { Sprite } from '@pixi/sprite';\n\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\n\n/**\n * Renders the object using the Canvas renderer\n * @method _renderCanvas\n * @memberof PIXI.Text#\n * @private\n * @param {PIXI.CanvasRenderer} renderer - The renderer\n */\nText.prototype._renderCanvas = function _renderCanvas(renderer: CanvasRenderer): void\n{\n    if (this._autoResolution && this._resolution !== renderer.resolution)\n    {\n        this._resolution = renderer.resolution;\n        this.dirty = true;\n    }\n\n    this.updateText(true);\n\n    Sprite.prototype._renderCanvas.call(this, renderer);\n};\n", "import { extensions } from 'pixi.js';\nimport { CanvasRenderer, canvasUtils } from '@pixi/canvas-renderer';\nimport { CanvasMeshRenderer } from '@pixi/canvas-mesh';\nimport { CanvasGraphicsRenderer } from '@pixi/canvas-graphics';\nimport { CanvasSpriteRenderer } from '@pixi/canvas-sprite';\nimport { CanvasExtract } from '@pixi/canvas-extract';\nimport { CanvasPrepare } from '@pixi/canvas-prepare';\nimport '@pixi/canvas-sprite-tiling';\nimport '@pixi/canvas-particle-container';\nimport '@pixi/canvas-display';\nimport '@pixi/canvas-text';\n\nextensions.add(\n    CanvasExtract,\n    CanvasGraphicsRenderer,\n    CanvasMeshRenderer,\n    CanvasPrepare,\n    CanvasSpriteRenderer\n);\n\n// Export ES for those importing specifically by name,\n// e.g., `import {autoDetectRenderer} from 'pixi.js-legacy'`\nexport * from 'pixi.js';\nexport {\n    CanvasRenderer,\n    CanvasGraphicsRenderer,\n    CanvasMeshRenderer,\n    CanvasSpriteRenderer,\n    CanvasExtract,\n    CanvasPrepare,\n    canvasUtils,\n};\n"],
  "mappings": "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",
  "names": ["d", "b", "CanvasMaskManager", "CanvasRenderer", "CanvasMeshRenderer", "_renderCanvas", "PolygonUtils", "CanvasGraphicsRenderer", "tempMatrix", "_renderCanvas", "CanvasSpriteRenderer", "_renderCanvas", "CanvasExtract", "extendStatics", "d", "b", "__extends", "CanvasPrepare", "_renderCanvas", "_renderCanvas", "renderCanvas", "_renderCanvas"]
}
